---
title: "Cross-Disease Translational Modeling"
author: "Brendan K. Ball"
date: "2024-03-15"
output: html_document
---

# 0. IMPORT PACKAGES
```{r Package Import, include=FALSE}
# Downloads and calls from the library the necessary packages needed to run the code
if(!require(stringr)) install.packages("stringr", repos = "http://cran.us.r-project.org")
suppressWarnings(library (stringr, verbose = FALSE))
if(!require(gtools)) install.packages("gtools", repos = "http://cran.us.r-project.org")
suppressWarnings(library (gtools, verbose = FALSE))
if(!require(dplyr)) install.packages("dplyr", repos = "http://cran.us.r-project.org")
suppressWarnings(library (dplyr, verbose = FALSE))
if(!require(factoextra)) install.packages("factoextra", repos = "http://cran.us.r-project.org")
suppressWarnings(library (factoextra, verbose = FALSE))
if(!require(devtools)) install.packages("devtools", repos = "http://cran.us.r-project.org")
suppressWarnings(library (devtools, verbose = FALSE))
if(!require(data.table)) install.packages("data.table", repos = "http://cran.us.r-project.org")
suppressWarnings(library (data.table, verbose = FALSE))
if(!require(tibble)) install.packages("tibble", repos = "http://cran.us.r-project.org")
suppressWarnings(library (tibble, verbose = FALSE))
if(!require(lme4)) install.packages("lme4", repos = "http://cran.us.r-project.org")
suppressWarnings(library (lme4, verbose = FALSE))
if(!require(emmeans)) install.packages("emmeans", repos = "http://cran.us.r-project.org")
suppressWarnings(library (emmeans, verbose = FALSE))
if(!require(effects)) install.packages("effects", repos = "http://cran.us.r-project.org")
suppressWarnings(library (effects, verbose = FALSE))
if(!require(ggforce)) install.packages("ggforce", repos = "http://cran.us.r-project.org")
suppressWarnings(library (ggforce, verbose = FALSE))
if(!require(pheatmap)) install.packages("pheatmap", repos = "http://cran.us.r-project.org")
suppressWarnings(library (pheatmap, verbose = FALSE))
if (!requireNamespace('BiocManager', quietly = TRUE))
  install.packages('BiocManager')
if(!require(EnhancedVolcano)) install.packages("EnhancedVolcano", repos = "http://cran.us.r-project.org")
suppressWarnings(library (EnhancedVolcano, verbose = FALSE)) # Imported using BiocManager::install("EnhancedVolcano")
if(!require(GEOquery)) install.packages("GEOquery", repos = "http://cran.us.r-project.org")
suppressWarnings(library (GEOquery, verbose = FALSE)) # Imported using BiocManager::install("GEOquery")
if(!require(orthogene)) install.packages("orthogene", repos = "http://cran.us.r-project.org")
suppressWarnings(library (orthogene, verbose = FALSE)) # Imported using BiocManager::install("orthogene")
if(!require(limma)) install.packages("limma", repos = "http://cran.us.r-project.org")
suppressWarnings(library (limma, verbose = FALSE))
if(!require(umap)) install.packages("umap", repos = "http://cran.us.r-project.org")
suppressWarnings(library (umap, verbose = FALSE))
if(!require(dplyr)) install.packages("dplyr", repos = "http://cran.us.r-project.org")
suppressWarnings(library (dplyr, verbose = FALSE))
if(!require(stringr)) install.packages("stringr", repos = "http://cran.us.r-project.org")
suppressWarnings(library (stringr, verbose = FALSE))
if(!require(powerjoin)) install.packages("powerjoin", repos = "http://cran.us.r-project.org")
suppressWarnings(library (powerjoin, verbose = FALSE))
if(!require(tidyr)) install.packages("tidyr", repos = "http://cran.us.r-project.org")
suppressWarnings(library (tidyr, verbose = FALSE))
if(!require(purrr)) install.packages("purrr", repos = "http://cran.us.r-project.org")
suppressWarnings(library (purrr, verbose = FALSE))
if(!require(fgsea)) install.packages("fgsea", repos = "http://cran.us.r-project.org")
suppressWarnings(library (fgsea, verbose = FALSE)) # Imported using BiocManager::install("fgsea")
if(!require(glmnet)) install.packages("glmnet", repos = "http://cran.us.r-project.org")
suppressWarnings(library (glmnet, verbose = FALSE))
if(!require(mixOmics)) install.packages("mixOmics", repos = "http://cran.us.r-project.org")
suppressWarnings(library (mixOmics, verbose = FALSE)) # Imported using BiocManager::install("mixOmics")
if(!require(org.Hs.eg.db)) install.packages("org.Hs.eg.db", repos = "http://cran.us.r-project.org")
suppressWarnings(library (org.Hs.eg.db, verbose = FALSE)) # Imported using BiocManager::install("org.Hs.eg.db")
if(!require(clusterProfiler)) install.packages("clusterProfiler", repos = "http://cran.us.r-project.org")
suppressWarnings(library (clusterProfiler, verbose = FALSE)) # Imported using BiocManager::install("clusterProfiler")
if(!require(tidyverse)) install.packages("tidyverse", repos = "http://cran.us.r-project.org")
suppressWarnings(library (tidyverse, verbose = FALSE))
if(!require(orthogene)) install.packages("orthogene", repos = "http://cran.us.r-project.org")
suppressWarnings(library (orthogene, verbose = FALSE))
if(!require(dittoSeq)) install.packages("dittoSeq", repos = "http://cran.us.r-project.org")
suppressWarnings(library (dittoSeq, verbose = FALSE)) # Imported using BiocManager::install("EnhancedVolcano")
if(!require(openxlsx)) install.packages("openxlsx", repos = "http://cran.us.r-project.org")
suppressWarnings(library (openxlsx, verbose = FALSE))
if(!require(EnrichmentBrowser)) install.packages("EnrichmentBrowser", repos = "http://cran.us.r-project.org")
suppressWarnings(library (EnrichmentBrowser, verbose = FALSE)) # Imported using BiocManager::install("EnrichmentBrowser")
if(!require(qusage)) install.packages("qusage", repos = "http://cran.us.r-project.org")
suppressWarnings(library (qusage, verbose = FALSE)) # Imported using BiocManager::install("qusage")
if(!require(ggpubr)) install.packages("ggpubr", repos = "http://cran.us.r-project.org")
suppressWarnings(library (ggpubr, verbose = FALSE))
if(!require(writexl)) install.packages("writexl", repos = "http://cran.us.r-project.org")
suppressWarnings(library (writexl, verbose = FALSE))
if (!require("msigdbr")) {BiocManager::install("msigdbr")}
suppressWarnings(library (msigdbr, verbose = FALSE))
if(!require(reshape2)) install.packages("reshape2", repos = "http://cran.us.r-project.org")
suppressWarnings(library (reshape2, verbose = FALSE))
if (!require("AnnotationDbi")) {BiocManager::install("AnnotationDbi")}
suppressWarnings(library (AnnotationDbi, verbose = FALSE))
if(!require(ggraph)) install.packages("ggraph", repos = "http://cran.us.r-project.org")
suppressWarnings(library (ggraph, verbose = FALSE))
if(!require(igraph)) install.packages("igraph", repos = "http://cran.us.r-project.org")
suppressWarnings(library (igraph, verbose = FALSE))
if(!require(tidygraph)) install.packages("tidygraph", repos = "http://cran.us.r-project.org")
suppressWarnings(library (tidygraph, verbose = FALSE))
```

# 1. IMPORT DATA SETS
```{r GSE184050 for Human T2D}
# Version info: R 4.2.2, Biobase 2.58.0, GEOquery 2.66.0, limma 3.54.0
# Data plots for selected GEO samples
# load counts table from GEO
urld <- "https://www.ncbi.nlm.nih.gov/geo/download/?format=file&type=rnaseq_counts"
path <- paste(urld, "acc=GSE184050", "file=GSE184050_raw_counts_GRCh38.p13_NCBI.tsv.gz", sep="&");
tbl <- as.matrix(data.table::fread(path, header=T, colClasses="integer"), rownames=1)
# pre-filter low count genes
# keep genes with at least 2 counts > 10
keep <- rowSums( tbl >= 10 ) >= 2
tbl <- tbl[keep, ]
# log transform raw counts
# instead of raw counts can display vst(as.matrix(tbl)) i.e. variance stabilized counts
dat <- log2(tbl + 1)
# box-and-whisker plot
dev.new(width=3+ncol(tbl)/6, height=5)
par(mar=c(7,4,2,1))
boxplot(dat, boxwex=0.7, notch=T, main="GSE184050", ylab="lg(cnt + 1)", outline=F, las=2)
dev.off()
# UMAP plot (dimensionality reduction)s
library(umap)
dat <- dat[!duplicated(dat), ] # first remove duplicates
ump <- umap(t(dat), n_neighbors = 15, random_state = 123)
plot(ump$layout, main="GSE184050 UMAP plot, nbrs =15", xlab="", ylab="", pch=20, cex=1.5)
library(car)
pointLabel(ump$layout, labels = rownames(ump$layout), method="SANN", cex=0.6)

humanT2D <- as.data.frame(dat)

# Entrez-to-Symbol Conversion and GSE184050 SubjectID Information for Human T2D Data
# Move the rowname to become the first column name
humanT2D_list <- tibble::rownames_to_column(humanT2D)
# Collect a list of Entrez-to-Symbol conversion list for human database
genesymbolconvert <- AnnotationDbi::select(org.Hs.eg.db, keys=as.character(as.matrix(humanT2D_list)), 
    columns="SYMBOL", keytype="ENTREZID")
genesymbolconvert <- genesymbolconvert[!is.na(genesymbolconvert$ENTREZID),]
# Rename the first entrez gene list as geneID for gene matching
colnames(genesymbolconvert)[1] <- "geneID"
# Move the row names to be in the first column
humanT2D_int <- tibble::rownames_to_column(humanT2D)
# Make standard geneID column name for combining data frame by column name
colnames(humanT2D_int)[1] <- "geneID"
# Combine the humanT2D_int file with the gene symbol conversion to create a gene list 
humanT2D_preproc <- genesymbolconvert %>% inner_join(humanT2D_int, by = 'geneID', copy = TRUE)
# Remove the Entrez gene list
humanT2D_preproc <- subset(humanT2D_preproc, select = -geneID)
# Rename the SYMBOLS column to geneID
colnames(humanT2D_preproc)[1] <- "geneID"
# Remove all entries with NA 
mut_human_gene_T2D <- humanT2D_preproc[complete.cases(humanT2D_preproc$geneID), ]

# Import GSE184050 SubjectID Information
GSE184050_subjectID <- read.csv("GSE184050_subjectID.csv")
```

```{r GSE63060 GPL6947 for Human AD Data Batch 1}
# Version info: R 4.2.2, Biobase 2.58.0, GEOquery 2.66.0, limma 3.54.0
# load series and platform data from GEO
gset <- getGEO("GSE63060", GSEMatrix =TRUE, getGPL=FALSE)
if (length(gset) > 1) idx <- grep("GPL6947", attr(gset, "names")) else idx <- 1
gset <- gset[[idx]]
ex <- exprs(gset)
# log2 transform
qx <- as.numeric(quantile(ex, c(0., 0.25, 0.5, 0.75, 0.99, 1.0), na.rm=T))
LogC <- (qx[5] > 100) ||
          (qx[6]-qx[1] > 50 && qx[2] > 0)
if (LogC) { ex[which(ex <= 0)] <- NaN
  ex <- log2(ex) }
# box-and-whisker plot
dev.new(width=3+ncol(gset)/6, height=5)
par(mar=c(7,4,2,1))
title <- paste ("GSE63060", "/", annotation(gset), sep ="")
boxplot(ex, boxwex=0.7, notch=T, main=title, outline=FALSE, las=2)
dev.off()
# expression value distribution plot
par(mar=c(4,4,2,1))
title <- paste ("GSE63060", "/", annotation(gset), " value distribution", sep ="")
plotDensities(ex, main=title, legend=F)
# mean-variance trend
ex <- na.omit(ex) # eliminate rows with NAs
plotSA(lmFit(ex), main="Mean variance trend, GSE63060")
# UMAP plot (multi-dimensional scaling)
ex <- ex[!duplicated(ex), ]  # remove duplicates

humanAD_batch1 <- as.data.frame(ex)

# Import GPL6947 Conversion and GSE63060 SubjectID Information for Human AD Data
# Import GSE63060 GPL6947 Import for Illumina HumanHT-12 V3.0 expression beadchip
GPL6947conv <- read.csv("GPL6947.csv")
GPL6947conv <- GPL6947conv[c(1,14)]

# Prepare the gene row name to be transferred to the mut_human df
gene_row_name_human_batch1 <- rownames(humanAD_batch1)
mut_human_names_batch1 <- cbind(gene_row_name_human_batch1, humanAD_batch1)
# Make standard geneID column name for df joining
colnames(mut_human_names_batch1)[1] <- "ID"
# Combine the mut_human_names file into the GPL570 data conversion to create a gene list 
mut_human_gene_batch1 <- GPL6947conv %>% inner_join(mut_human_names_batch1, by = 'ID', copy = TRUE)
# Rename the second column Gene.Symbol to geneID
colnames(mut_human_gene_batch1)[2] <- "geneID"
# Replace empty entries with NA
mut_human_gene_batch1 <- mut_human_gene_batch1 %>% mutate(geneID = ifelse(geneID == "", NA, geneID))
# Remove the Entrez gene list
mut_human_gene_batch1 <- subset(mut_human_gene_batch1, select = -ID)
# Remove all entries with NA 
mut_human_gene_batch1 <- mut_human_gene_batch1[complete.cases(mut_human_gene_batch1$geneID), ]
# Remove duplicate genes by taking the average across genes with duplicate entries
mut_human_gene_batch1 <- aggregate(mut_human_gene_batch1[-1], list(mut_human_gene_batch1$geneID), mean)

# Import GSE48350 SubjectID Information
GSE63060_subjectID <- read.csv("GSE63060_subjectID.csv")
```

```{r GSE63061 GPL10558 for Human AD Data Batch 2}
# Version info: R 4.2.2, Biobase 2.58.0, GEOquery 2.66.0, limma 3.54.0
# load series and platform data from GEO
gset <- getGEO("GSE63061", GSEMatrix =TRUE, getGPL=FALSE)
if (length(gset) > 1) idx <- grep("GPL10558", attr(gset, "names")) else idx <- 1
gset <- gset[[idx]]
ex <- exprs(gset)
# log2 transform
qx <- as.numeric(quantile(ex, c(0., 0.25, 0.5, 0.75, 0.99, 1.0), na.rm=T))
LogC <- (qx[5] > 100) ||
          (qx[6]-qx[1] > 50 && qx[2] > 0)
if (LogC) { ex[which(ex <= 0)] <- NaN
  ex <- log2(ex) }
# box-and-whisker plot
dev.new(width=3+ncol(gset)/6, height=5)
par(mar=c(7,4,2,1))
title <- paste ("GSE63061", "/", annotation(gset), sep ="")
boxplot(ex, boxwex=0.7, notch=T, main=title, outline=FALSE, las=2)
dev.off()
# expression value distribution plot
par(mar=c(4,4,2,1))
title <- paste ("GSE63061", "/", annotation(gset), " value distribution", sep ="")
plotDensities(ex, main=title, legend=F)
# mean-variance trend
ex <- na.omit(ex) # eliminate rows with NAs
plotSA(lmFit(ex), main="Mean variance trend, GSE63061")
# UMAP plot (multi-dimensional scaling)
ex <- ex[!duplicated(ex), ]  # remove duplicates

humanAD_batch2 <- as.data.frame(ex)

# Import GPL10558 Conversion and GSE63061 SubjectID Information for Human AD Data
# Import GSE63061 GPL10058 Import for Illumina HumanHT-12 V4.0 expression beadchip
GPL10058conv <- read.csv("GPL10558.csv")
GPL10058conv <- GPL10058conv[c(1,13)]

# Prepare the gene row name to be transferred to the mut_human df
gene_row_name_human_batch2 <- rownames(humanAD_batch2)
mut_human_names_batch2 <- cbind(gene_row_name_human_batch2, humanAD_batch2)
# Make standard geneID column name for df joining
colnames(mut_human_names_batch2)[1] <- "ID"
# Combine the mut_human_names file into the GPL570 data conversion to create a gene list 
mut_human_gene_batch2 <- GPL10058conv %>% inner_join(mut_human_names_batch2, by = 'ID', copy = TRUE)
# Rename the second column Gene.Symbol to geneID
colnames(mut_human_gene_batch2)[2] <- "geneID"
# Replace empty entries with NA
mut_human_gene_batch2 <- mut_human_gene_batch2 %>% mutate(geneID = ifelse(geneID == "", NA, geneID))
# Remove the Entrez gene list
mut_human_gene_batch2 <- subset(mut_human_gene_batch2, select = -ID)
# Remove all entries with NA 
mut_human_gene_batch2 <- mut_human_gene_batch2[complete.cases(mut_human_gene_batch2$geneID), ]
# Remove duplicate genes by taking the average across genes with duplicate entries
mut_human_gene_batch2 <- aggregate(mut_human_gene_batch2[-1], list(mut_human_gene_batch2$geneID), mean)

# Import GSE48350 SubjectID Information
GSE63061_subjectID <- read.csv("GSE63061_subjectID.csv")
```

# 2. DATA WRANGLING & PROCESSING
## 2.1 Gene Matching Across Human Data
```{r Preparation of Gene List with Respective Converters}
# 3-Way Intersection of Genes Across Human Data
# Prepare each individual human data set into the format such that subjectID is in the row name
# Additionally, each gene expression represents a column
# Human T2D Data Set
rownames(mut_human_gene_T2D) <- NULL
mut_human_gene_T2D <- as.data.frame(mut_human_gene_T2D)
# Set the first column (Name) as row names
mut_human_gene_T2D <- mut_human_gene_T2D %>% remove_rownames %>% column_to_rownames(var="geneID")
# Take the transpose of the data
mut_human_gene_T2D_t <- t(mut_human_gene_T2D)

# Human AD Data Set Batch 1
rownames(mut_human_gene_batch1) <- NULL
mut_human_gene_batch1 <- as.data.frame(mut_human_gene_batch1)
colnames(mut_human_gene_batch1)[1] <- "geneID"
# Set the first column (Name) as row names
mut_human_gene_batch1 <- mut_human_gene_batch1 %>% remove_rownames %>% column_to_rownames(var="geneID")
# Take the transpose of the data
mut_human_gene_batch1_t <- t(mut_human_gene_batch1)

# Human AD Data Set Batch 2
rownames(mut_human_gene_batch2) <- NULL
mut_human_gene_batch2 <- as.data.frame(mut_human_gene_batch2)
colnames(mut_human_gene_batch2)[1] <- "geneID"
# Set the first column (Name) as row names
mut_human_gene_batch2 <- mut_human_gene_batch2 %>% remove_rownames %>% column_to_rownames(var="geneID")
# Take the transpose of the data
mut_human_gene_batch2_t <- t(mut_human_gene_batch2)

# Only save data that has genes that intersect between the humans and mouse data 3-way
col_extracted <- intersect(colnames(mut_human_gene_T2D_t), colnames(mut_human_gene_batch1_t))
col_extracted_all <- intersect(colnames(mut_human_gene_batch2_t), col_extracted)
# Define the mouse and human genes that are crossed together for matching
humandat_T2D_proc_int <- mut_human_gene_T2D_t[,col_extracted_all]
humandat_batch1_proc_int <- mut_human_gene_batch1_t[,col_extracted_all]
humandat_batch2_proc_int <- mut_human_gene_batch2_t[,col_extracted_all]
# Calculate the percent of genes preserved from each data set
percentdrop_T2D_proc <- ncol(humandat_T2D_proc_int)/ncol(mut_human_gene_T2D_t)
percentdrop_batch2_proc <- ncol(humandat_batch1_proc_int)/ncol(mut_human_gene_batch1_t)
percentdrop_batch1_proc <- ncol(humandat_batch2_proc_int)/ncol(mut_human_gene_batch2_t)
```

## 2.2 Incorporation of Subject Information into Data
```{r Merging SubjectID Identifiers Into Data}
# Function to calculate z-score for a vector
calc_z_score <- function(x) {
  (x - mean(x)) / sd(x)
}

# Subject Information with Human Data for the T2D Group
# Human Data Combination
# Move the row names to be in the first column
humandat_T2D_proc_int <- as.data.frame(humandat_T2D_proc_int)
humandat_T2D_proc_int <- tibble::rownames_to_column(humandat_T2D_proc_int)
colnames(humandat_T2D_proc_int)[1] <- "SubjectID"
# Replace Disease.state with Condition in column name
names(GSE184050_subjectID)[which(names(GSE184050_subjectID) == "Disease.state")] <- "Condition"
# Replace Condition String with T2D or C (T2D=Type 2 Diabetes, C=Control)
GSE184050_subjectID$Condition[GSE184050_subjectID$Condition == 'T2D case'] <- 'T2D'
GSE184050_subjectID$Condition[GSE184050_subjectID$Condition == 'control'] <- 'C'
# Convert the age column to numeric
GSE184050_subjectID$Age <- as.numeric(GSE184050_subjectID$Age)
# Replace Sex String with F or M (F=Female, M=Male)
GSE184050_subjectID$Sex[GSE184050_subjectID$Sex == 'female'] <- 'F'
GSE184050_subjectID$Sex[GSE184050_subjectID$Sex == 'male'] <- 'M'
# Remove the excess columns not needed for analysis
GSE184050_subjectID = GSE184050_subjectID[,!(names(GSE184050_subjectID) %in% c("Group","Title", "Tissue","Individual", "Sample.type"))]
# Replace Accession with SampleID in column name
names(GSE184050_subjectID)[which(names(GSE184050_subjectID) == "Accession")] <- "SubjectID"
# Combine the subjectID and human data to create the Xh dataset
X_T2Ddat <- GSE184050_subjectID %>% inner_join(humandat_T2D_proc_int, by = 'SubjectID', copy = TRUE)
# Pull data from baseline only for now (to reduce double counting the same participant)
X_T2Ddat <- X_T2Ddat[(X_T2Ddat$Timepoint %in% "baseline"),]
# Save copy of the data set with all age groups
X_T2Ddat_all <- X_T2Ddat
# Remove any age groups below 55 years old to reduce factors of age
X_T2Ddat <- subset(X_T2Ddat, Age>55) 

# Make the data portions numeric
for (i in 7:ncol(X_T2Ddat)) {
  X_T2Ddat[,i] <- as.numeric(X_T2Ddat[,i])
}

# Save a non-normalized version
X_T2Ddat_NN <- X_T2Ddat

# Loop through each column and apply the z-score transformation for mouse before PCA
for (i in 7:ncol(X_T2Ddat)) {
  X_T2Ddat[,i] <- calc_z_score(X_T2Ddat[,i])
}

# Subject Information with Human Data for the AD Group BATCH 1
# Human Data Combination
# Move the row names to be in the first column
humandat_batch1_proc_int <- as.data.frame(humandat_batch1_proc_int)
humandat_batch1_proc_int <- tibble::rownames_to_column(humandat_batch1_proc_int)
colnames(humandat_batch1_proc_int)[1] <- "SubjectID"
# Replace Status with Condition in column name
names(GSE63060_subjectID)[which(names(GSE63060_subjectID) == "Status")] <- "Condition"
# Replace Condition String with AD, MCI, or C (AD=Alzheimer's Disease, MCI=Mild Cognitive Impairment, C=Control)
GSE63060_subjectID$Condition[GSE63060_subjectID$Condition == 'CTL'] <- 'C'
# Convert the age column to numeric
GSE63060_subjectID$Age <- as.numeric(GSE63060_subjectID$Age)
# Replace Gender with Sex in column name
names(GSE63060_subjectID)[which(names(GSE63060_subjectID) == "Gender")] <- "Sex"
# Replace Sex String with F or M (F=Female, M=Male)
GSE63060_subjectID$Sex[GSE63060_subjectID$Sex == 'Female'] <- 'F'
GSE63060_subjectID$Sex[GSE63060_subjectID$Sex == 'Male'] <- 'M'
# Remove the excess columns not needed for analysis
GSE63060_subjectID = GSE63060_subjectID[,!(names(GSE63060_subjectID) %in% c("Group","Title", "Source.name", "Ethnicity","Included.in.case..control.study", "Tissue"))]
# Replace Accession with SampleID in column name
names(GSE63060_subjectID)[which(names(GSE63060_subjectID) == "Accession")] <- "SubjectID"
# Combine the subjectID and human data to create the Xh dataset
X_batch1dat <- GSE63060_subjectID %>% inner_join(humandat_batch1_proc_int, by = 'SubjectID', copy = TRUE)
# Remove MCI from the study
X_batch1dat <- X_batch1dat[!(X_batch1dat$Condition %in% "MCI"),]
# Only pull data that contains AD and C
X_batch1dat <- X_batch1dat[grepl("AD|C", X_batch1dat$Condition) & !grepl("CTL", X_batch1dat$Condition) & !grepl("OTHER", X_batch1dat$Condition) & !grepl("borderline MCI", X_batch1dat$Condition), ]
# Save copy of the data set with all age groups
X_batch1dat_all <- X_batch1dat
# Remove any age groups below 55 years old to reduce factors of age
X_batch1dat <- subset(X_batch1dat, Age>55) 

# Make the data portions numeric
for (i in 5:ncol(X_batch1dat)) {
  X_batch1dat[,i] <- as.numeric(X_batch1dat[,i])
}

# Save a non-normalized version
X_batch1dat_NN <- X_batch1dat

# Loop through each column and apply the z-score transformation for mouse before PCA
for (i in 5:ncol(X_batch1dat)) {
  X_batch1dat[,i] <- calc_z_score(X_batch1dat[,i])
}

# Subject Information with Human Data for the AD Group BATCH 2

# Human Data Combination
# Move the row names to be in the first column
humandat_batch2_proc_int <- as.data.frame(humandat_batch2_proc_int)
humandat_batch2_proc_int <- tibble::rownames_to_column(humandat_batch2_proc_int)
colnames(humandat_batch2_proc_int)[1] <- "SubjectID"
# Replace Status with Condition in column name
names(GSE63061_subjectID)[which(names(GSE63061_subjectID) == "Status")] <- "Condition"
# Replace Condition String with AD, MCI, or C (AD=Alzheimer's Disease, MCI=Mild Cognitive Impairment, C=Control)
GSE63061_subjectID$Condition[GSE63061_subjectID$Condition == 'CTL'] <- 'C'
# Convert the age column to numeric
GSE63061_subjectID$Age <- as.numeric(GSE63061_subjectID$Age)
# Replace Gender with Sex in column name
names(GSE63061_subjectID)[which(names(GSE63061_subjectID) == "Gender")] <- "Sex"
# Replace Sex String with F or M (F=Female, M=Male)
GSE63061_subjectID$Sex[GSE63061_subjectID$Sex == 'Female'] <- 'F'
GSE63061_subjectID$Sex[GSE63061_subjectID$Sex == 'Male'] <- 'M'
# Remove the excess columns not needed for analysis
GSE63061_subjectID = GSE63061_subjectID[,!(names(GSE63061_subjectID) %in% c("Group","Title", "Source.name", "Ethnicity","Included.in.case..control.study", "Tissue"))]
# Replace Accession with SampleID in column name
names(GSE63061_subjectID)[which(names(GSE63061_subjectID) == "Accession")] <- "SubjectID"
# Combine the subjectID and human data to create the Xh dataset
X_batch2dat <- GSE63061_subjectID %>% inner_join(humandat_batch2_proc_int, by = 'SubjectID', copy = TRUE)
# Remove MCI from the study
X_batch2dat <- X_batch2dat[!(X_batch2dat$Condition %in% "MCI"),]
# Only pull data that contains AD and C
X_batch2dat <- X_batch2dat[grepl("AD|C", X_batch2dat$Condition) & !grepl("CTL", X_batch2dat$Condition) & !grepl("OTHER", X_batch2dat$Condition) & !grepl("borderline MCI", X_batch2dat$Condition), ]
# Save copy of the data set with all age groups
X_batch2dat_all <- X_batch2dat
# Remove any age groups below 55 years old to reduce factors of age
X_batch2dat <- subset(X_batch2dat, Age>55) 

# Make the data portions numeric
for (i in 5:ncol(X_batch2dat)) {
  X_batch2dat[,i] <- as.numeric(X_batch2dat[,i])
}

# Save a non-normalized version
X_batch2dat_NN <- X_batch2dat

# Loop through each column and apply the z-score transformation for mouse before PCA
for (i in 5:ncol(X_batch2dat)) {
  X_batch2dat[,i] <- calc_z_score(X_batch2dat[,i])
}
```

# 3. DATA VISUALIZATION 
## 3.1 Plotting the PCA Charts for the Pre-Processed Human Data Set
```{r PCA of Human T2D Dataset Unfiltered}
# PCA of the Human AD-Only Dataset (Unfiltered)
# Data frame for the PCA
X_T2Ddat_pca <- X_T2Ddat
# Prepare the principal components
X_T2Ddat_pr <- prcomp(X_T2Ddat_pca[c(7:ncol(X_T2Ddat_pca))], center = TRUE, scale = FALSE)

#svg('PCA_T2D.svg', width = 4, height = 4)
# Create PCA chart with coloring/grouping based on different disease status in human
g1 <- fviz_pca_ind(X_T2Ddat_pr, label="none", alpha.ind=1, pointshape=19, habillage=X_T2Ddat_pca$Condition, pointsize = 1, repel = TRUE, col.ind = "black", invisible="quali",legend.title = "Disease Status",
             palette = c("#4575b4","#d73027"))

g1 +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
  theme_bw() +
  theme(
    panel.grid.major = element_blank(),  # Remove major gridlines
    panel.grid.minor = element_blank(),   # Remove minor gridlines
    aspect.ratio=1
  )
#dev.off()
```

```{r PCA of Human AD Batch 1 Dataset Unfiltered}
# PCA of the Human AD-Only Dataset (Unfiltered)
# Data frame for the PCA
X_batch1dat_pca <- X_batch1dat
# Prepare the principal components
X_batch1dat_pr <- prcomp(X_batch1dat_pca[c(5:ncol(X_batch1dat_pca))], center = TRUE, scale = FALSE)

#svg('PCA_AD1.svg', width = 4, height = 4)
# Create PCA chart with coloring/grouping based on different disease status in human
g1 <- fviz_pca_ind(X_batch1dat_pr, label="none", alpha.ind=1, pointshape=19, habillage=X_batch1dat_pca$Condition, pointsize = 1, repel = TRUE, col.ind = "black", invisible="quali",legend.title = "Disease Status",
             palette = c("#d73027", "#4575b4"))

g1 +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
  theme_bw() +
  theme(
    panel.grid.major = element_blank(),  # Remove major gridlines
    panel.grid.minor = element_blank(),   # Remove minor gridlines
    aspect.ratio=1
  )
#dev.off()
```

```{r PCA of Human AD Batch 2 Dataset Unfiltered}
# PCA of the Human AD-Only Dataset (Unfiltered)
# Data frame for the PCA
X_batch2dat_pca <- X_batch2dat
# Prepare the principal components
X_batch2dat_pr <- prcomp(X_batch2dat_pca[c(5:ncol(X_batch2dat_pca))], center = TRUE, scale = FALSE)

#svg('PCA_AD2.svg', width = 4, height = 4)
# Create PCA chart with coloring/grouping based on different disease status in human
g2 <- fviz_pca_ind(X_batch2dat_pr, label="none", alpha.ind=1, pointshape=19, habillage=X_batch2dat_pca$Condition, pointsize = 1, repel = TRUE, col.ind = "black", invisible="quali",legend.title = "Disease Status",
             palette = c("#d73027", "#4575b4"))

g2 +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
  theme_bw() +
  theme(
    panel.grid.major = element_blank(),  # Remove major gridlines
    panel.grid.minor = element_blank(),   # Remove minor gridlines
    aspect.ratio=1
  )
#dev.off()
```

# 4 CROSS-DISEASE MODELING 
## 4.1 Cumulative Variance Plot for PCs that Explain 80% Variance
```{r Filtering PCs to 80% Explained Variance}
# Q_T2D data matrix preparation 
# Remove the identifiers and keep the genes based on each mouse data
X_T2Ddat_TCR <- X_T2Ddat[c(7:ncol(X_T2Ddat))]
# Take the transpose of the data frame
X_T2Ddat_TCR_t <- t(X_T2Ddat_TCR)
# Reset as a data frame
X_T2Ddat_TCR_t <- as.data.frame(X_T2Ddat_TCR_t)
# Move the row names into the first column
X_T2Ddat_TCR_t <- tibble::rownames_to_column(X_T2Ddat_TCR_t)
colnames(X_T2Ddat_TCR_t)[1] <- "GeneID"
# Prepare the principal component analysis
Q_T2Ddat_pr <- prcomp(X_T2Ddat_TCR_t[c(2:(ncol(X_T2Ddat_TCR_t)))], center = TRUE, scale = FALSE)

# Prepare the Scree Plot for T2D data
screeplot(Q_T2Ddat_pr, type = "l", npcs = 25, main = "Scree Plot of the 25PCs")
abline(h = 1, col="red", lty=20)
legend("topright", legend=c("Eigenvalue = 1"),
       col=c("red"), lty=5, cex=0.6)
# Cumulative Variance Plot for 80% Variance
cumVar <- cumsum(Q_T2Ddat_pr$sdev^2 / sum(Q_T2Ddat_pr$sdev^2))
#svg('cumulativeVarPlot.svg', width = 4, height = 4)
plot(cumVar[0:25], xlab = "Principle Component #", ylab = "Amount of Explained Variance", main = "Cumulative Variance Plot")
abline(v = 13, col="blue", lty=5)
abline(h = 0.80, col="blue", lty=5)
legend("bottomright", legend=c("Cut-off @ PC13"),
       col=c("blue"), lty=5, cex=0.6)
#dev.off()
# Identify number of PCs => 80%
print(c("Princial components at 80% variance is:", which(cumVar >= 0.80)[1]))
PC_80_val <- as.numeric(which(cumVar >= 0.80)[1])
```

## 4.2 Translatable Components Regression (TransComp-R) Batch 1
```{r TransComp-R and AD Human Batch 1}
# Collect the PCs of the mouse data set
Q_T2D <- Q_T2Ddat_pr$x
# Extract PC1 to PCs that represent 80% explained variability
Q_T2D <-  Q_T2D[, c(1:PC_80_val)]

# Keep row names as the gene identifiers
rownames(Q_T2D) <- X_T2Ddat_TCR_t$GeneID
# Preparation of the T2D matrix
Q_T2D <- as.matrix(Q_T2D)

# X_human data matrix preparation
# Remove the identifiers and keep the genes based on each T2D data
X_ADbatch1_TCR <- X_batch1dat[c(5:ncol(X_batch1dat))]
# Rename the row names as the subject ID
rownames(X_ADbatch1_TCR) <- X_batch1dat$SubjectID
# Convert the X_human data into a matrix form
X_ADbatch1 <- as.matrix(X_ADbatch1_TCR)

# Matrix multiplication of the human and mouse data set
P_T2D_AD <- X_ADbatch1 %*% Q_T2D
# Make the mouse-human matrix into a data frame
P_T2D_AD_DF <- as.data.frame(P_T2D_AD)
# Move the row names into the first column
P_T2D_AD_DF <- tibble::rownames_to_column(P_T2D_AD_DF)
colnames(P_T2D_AD_DF)[1] <- "SubjectID"
# Make the Mouse to human TransComp-R data with human demographic information
T2D_AD_TCR <- X_batch1dat[c(1:4)] %>% inner_join(P_T2D_AD_DF, by = 'SubjectID', copy = TRUE)

# Regression and Variable Selection
# Rename the condition categories into numerical values for the regression analysis
T2D_AD_TCR_reg <- T2D_AD_TCR %>%
  mutate(Condition = case_when(
    Condition == "AD" ~ 1,  # Replace "AD" with 1
    Condition == "C" ~ 0,  # Replace "C" with 0
  ))

# Rename the male and female sex categories into numerical values for the regression analysis
T2D_AD_TCR_reg <- T2D_AD_TCR_reg %>%
  mutate(Sex = case_when(
    Sex == "M" ~ -1,  # Replace "male" with -1
    Sex == "F" ~ 1,  # Replace "female" with 1
  ))

# Incorporate the PC*Sex Interaction term
# Specify the number of PCs from the mouse group
num_pcs <- PC_80_val  # The total number of PCs

# Loop to create new columns for sex interaction
for (i in 1:num_pcs) {
  col_name <- paste0("Sex_PC", i)  # Create a new column name with PC number
  T2D_AD_TCR_reg <- T2D_AD_TCR_reg %>%
    mutate(!!col_name := Sex * get(paste0("PC", i)))  # Perform the interaction multiplication
}
# Loop to create new columns for age interaction
for (i in 1:num_pcs) {
  col_name <- paste0("Age_PC", i)  # Create a new column name with PC number
  T2D_AD_TCR_reg <- T2D_AD_TCR_reg %>%
    mutate(!!col_name := Age * get(paste0("PC", i)))  # Perform the interaction multiplication
}
```

## 4.3 LASSO and PC Selection
```{r Cross Validation with PC with Sex and Age, and Sex*PC and Age*PC Interactions}
set.seed(1)
# Number of repeats
num_repeats <- 20
# Initialize list to store coefficients
coefs_list_all_int <- list()

# Repeat the process
for (i in 1:num_repeats) {
    # Define response variable
    y_all_int <- T2D_AD_TCR_reg$Condition
    # Define matrix of predictor variables
    x_all_int <- data.matrix(T2D_AD_TCR_reg[c(3:ncol(T2D_AD_TCR_reg))])
    # Perform 10-fold cross-validation to find optimal lambda value
    cv_model_all_int <- cv.glmnet(x_all_int, y_all_int, alpha = 1, grouped = FALSE, family = "binomial", type.measure = "class", nfolds = 10, maxit = 1000000)
    # Find optimal lambda value that minimizes test MSE
    best_lambda_all_int <- cv_model_all_int$lambda.min
    # Find coefficients of best model
    best_model_all_int <- glmnet(x_all_int, y_all_int, alpha = 1, lambda = best_lambda_all_int, nfolds = 10, family = "binomial", type.measure = "class", maxit = 1000000)
    # Store coefficients for each repetition of the model
    coefs_list_all_int[[i]] <- as.vector(coef(best_model_all_int))
}

# Convert coefficients list to data frame
coefs_lasso_all_int <- as.data.frame(do.call(cbind, coefs_list_all_int))
# Replace the column name to represent each iteration re-run of the LASSO model
colnames(coefs_lasso_all_int) <- sub("^V", "Iter", colnames(coefs_lasso_all_int))
# Count non-zero coefficients in each row
coefs_lasso_all_int$non_zero_count <- rowSums(coefs_lasso_all_int != 0)
# Mark as TRUE in a new column if greater than 4 non-zero counts
coefs_lasso_all_int$variable_selection <- coefs_lasso_all_int$non_zero_count > 4
# Include row names of the coefficients
rownames(coefs_lasso_all_int) <- c("Intercept", colnames(x_all_int))
# Pull out the count for number of non-zero coefficients
count_lasso_all_int <- coefs_lasso_all_int[c("non_zero_count","variable_selection")]
# Move the row names to be in the first column
count_lasso_all_int <- tibble::rownames_to_column(count_lasso_all_int)
colnames(count_lasso_all_int)[1] <- "Variables"

# Reorder the row names
desired_order <- c("Sex", "Age", "PC1", "PC2", "PC3", "PC4", "PC5",
                   "PC6", "PC7", "PC8", "PC9", "PC10",
                   "PC11", "PC12", "PC13", 
                   "Sex_PC1", "Sex_PC2", "Sex_PC3", "Sex_PC4", "Sex_PC5",
                   "Sex_PC6", "Sex_PC7", "Sex_PC8", "Sex_PC9", "Sex_PC10",
                   "Sex_PC11", "Sex_PC12", "Sex_PC13",
                   "Age_PC1", "Age_PC2", "Age_PC3", "Age_PC4", "Age_PC5",
                   "Age_PC6", "Age_PC7", "Age_PC8", "Age_PC9", "Age_PC10",
                   "Age_PC11", "Age_PC12", "Age_PC13")

count_lasso_all_int$Variables <- factor(count_lasso_all_int$Variables, levels = count_lasso_all_int$Var)

# Remove the intercept from the bar graph
count_lasso_all_int_plot <- count_lasso_all_int[-1, ]

# Create color vector
colors <- ifelse(count_lasso_all_int$variable_selection == TRUE, "#7D7D7D","orange")

# Create the bar plot
ggplot(count_lasso_all_int_plot, aes(x = reorder(Variables, -match(Variables, desired_order)), y = non_zero_count, fill = variable_selection)) +
  geom_bar(stat = "identity", color = "black", linewidth = 0.2) +
  scale_fill_manual(values = colors) +
  labs(x = "Variables",
       y = "Non-Zero Count") +
  theme(axis.text.y = element_text(size = 12)) +
  coord_flip() + theme_classic() + geom_hline(yintercept = 5, linetype = "dashed", color = "black") +
  scale_y_continuous(expand = expansion(mult = c(0, 0.01)))  # Adjust the limits of y-axis
```

```{r Non-Zero LASSO Coefficient Frequency of Model with PC, Sex*PC, and Age*PC}
count_lasso_all_int_plot$Variables <- as.character(count_lasso_all_int_plot$Variables)
# Remove the sex and age only terms for the heatmap purpose
count_lasso_all_int_plot <- count_lasso_all_int_plot[grepl("PC", count_lasso_all_int_plot$Variables), ]

# Pull out individual PCs without interaction terms
lasso_counts_all_int_noInt <- count_lasso_all_int_plot[!grepl("Sex|Age", count_lasso_all_int_plot$Variables), ]
# Pull out individual PCs related to Sex interaction
lasso_counts_all_int_Sex <- count_lasso_all_int_plot[grepl("Sex", count_lasso_all_int_plot$Variables), ]
# Pull out individual PCs related to Age interaction
lasso_counts_all_int_Age <- count_lasso_all_int_plot[grepl("Age", count_lasso_all_int_plot$Variables), ]

# Combine the frequencies into a new data frame
lasso_counts_all_int <- as.data.frame(cbind(lasso_counts_all_int_noInt$non_zero_count, lasso_counts_all_int_Sex$non_zero_count, lasso_counts_all_int_Age$non_zero_count))
colnames(lasso_counts_all_int)[1] <- "PC"
colnames(lasso_counts_all_int)[2] <- "PC*Sex"
colnames(lasso_counts_all_int)[3] <- "PC*Age"

# Set the row names of the matrix with respective PC number
row_labels <- 1:13
rownames(lasso_counts_all_int) <- paste(row_labels, rownames(lasso_counts_all_int), sep = " ")
lasso_counts_all_int_map <- lasso_counts_all_int
# Convert to matrix format for the heatmap
lasso_counts_all_int_matrix <- as.matrix(lasso_counts_all_int_map)

#svg('LASSO_ADCohort1.svg', width = 2, height = 4)
# Generate the heatmap for the PCs from the LASSO model
heatmapfig <- pheatmap(lasso_counts_all_int_matrix,
  cluster_rows = FALSE,
  cluster_cols = FALSE,
  color = colorRampPalette(c("white", "orange"))(21),
  border_color = "black",
  breaks = seq(0, 20, length.out = 21),
  angle_col = 90,
  fontsize_col = 9,
  fontsize_row = 9,
  show_rownames = TRUE)
#dev.off()
```

```{r GLM Regression Modeling for PCs}
# GLM on T2D PCs of interest
model_list <- glm(Condition ~ PC2, data = T2D_AD_TCR_reg, family = binomial, maxit=100)
summary(model_list)

model_list <- glm(Condition ~ PC3, data = T2D_AD_TCR_reg, family = binomial, maxit=100)
summary(model_list)

model_list <- glm(Condition ~ PC5, data = T2D_AD_TCR_reg, family = binomial, maxit=100)
summary(model_list)

model_list <- glm(Condition ~ PC6, data = T2D_AD_TCR_reg, family = binomial, maxit=100)
summary(model_list)

model_list <- glm(Condition ~ PC7, data = T2D_AD_TCR_reg, family = binomial, maxit=100)
summary(model_list)

model_list <- glm(Condition ~ PC8, data = T2D_AD_TCR_reg, family = binomial, maxit=100)
summary(model_list)

model_list <- glm(Condition ~ PC9, data = T2D_AD_TCR_reg, family = binomial, maxit=100)
summary(model_list)

model_list <- glm(Condition ~ PC10, data = T2D_AD_TCR_reg, family = binomial, maxit=100)
summary(model_list)

model_list <- glm(Condition ~ PC11, data = T2D_AD_TCR_reg, family = binomial, maxit=100)
summary(model_list)

model_list <- glm(Condition ~ PC12, data = T2D_AD_TCR_reg, family = binomial, maxit=100)
summary(model_list)

model_list <- glm(Condition ~ PC13, data = T2D_AD_TCR_reg, family = binomial, maxit=100)
summary(model_list)
```

## 4.3 Plot PCs Identified as Significant from TransComp-R and GLM
```{r PC2 and PC5}
#svg('PC2PC5_cohort1.svg', width = 4, height = 4)
# Create ggplot of the different PCs from TransComp-R
g2 <- ggplot(T2D_AD_TCR_reg, aes(x = PC2, y = PC5, color = Condition)) + 
  geom_point(shape = 16, size = 1.0, color = "black") + 
  geom_point(size = 1.0) +
  scale_color_manual(values = c("#4575b4","#d73027")) +
  theme(legend.position = 'right') +
  coord_equal() 

# Factorize the Condition (AD vs Control)
g2$data$Condition <- as.factor(g2$data$Condition)

# Plot the figure
g2 +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
  theme_bw() +
  theme(
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank(),
    aspect.ratio = 1
  )
#dev.off()
```

```{r PC6 and PC11}
#svg('PC6PC11_cohort1.svg', width = 4, height = 4)
# Create ggplot of the different PCs from TransComp-R
g2 <- ggplot(T2D_AD_TCR_reg, aes(x = PC6, y = PC11, color = Condition)) + 
  geom_point(shape = 16, size = 1.0, color = "black") + 
  geom_point(size = 1.0) +
  scale_color_manual(values = c("#4575b4","#d73027")) +
  theme(legend.position = 'right') +
  coord_equal() 

# Factorize the Condition (AD vs Control)
g2$data$Condition <- as.factor(g2$data$Condition)

# Plot the figure
g2 +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
  theme_bw() +
  theme(
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank(),
    aspect.ratio = 1
  )
#dev.off()
```

## 4.4 Translatable Components Regression (TransComp-R) Batch 2
```{r TransComp-R and AD Human Batch 2}
# Collect the PCs of the mouse data set
Q_T2D <- Q_T2Ddat_pr$x
# Extract PC1 to PCs that represent 80% explained variability
Q_T2D <-  Q_T2D[, c(1:PC_80_val)]

# Keep row names as the gene identifiers
rownames(Q_T2D) <- X_T2Ddat_TCR_t$GeneID
# Preparation of the T2D matrix
Q_T2D <- as.matrix(Q_T2D)

# X_human data matrix preparation
# Remove the identifiers and keep the genes based on each T2D data
X_ADbatch2_TCR <- X_batch2dat[c(5:ncol(X_batch2dat))]
# Rename the row names as the subject ID
rownames(X_ADbatch2_TCR) <- X_batch2dat$SubjectID
# Convert the X_human data into a matrix form
X_ADbatch2 <- as.matrix(X_ADbatch2_TCR)

# Matrix multiplication of the human and mouse data set
P_T2D_AD <- X_ADbatch2 %*% Q_T2D
# Make the mouse-human matrix into a data frame
P_T2D_AD_DF <- as.data.frame(P_T2D_AD)
# Move the row names into the first column
P_T2D_AD_DF <- tibble::rownames_to_column(P_T2D_AD_DF)
colnames(P_T2D_AD_DF)[1] <- "SubjectID"
# Make the Mouse to human TransComp-R data with human demographic information
T2D_AD_TCR2 <- X_batch2dat[c(1:4)] %>% inner_join(P_T2D_AD_DF, by = 'SubjectID', copy = TRUE)

# Regression and Variable Selection
# Rename the condition categories into numerical values for the regression analysis
T2D_AD_TCR_reg2 <- T2D_AD_TCR2 %>%
  mutate(Condition = case_when(
    Condition == "AD" ~ 1,  # Replace "AD" with 1
    Condition == "C" ~ 0,  # Replace "C" with 0
  ))

# Rename the male and female sex categories into numerical values for the regression analysis
T2D_AD_TCR_reg2 <- T2D_AD_TCR_reg2 %>%
  mutate(Sex = case_when(
    Sex == "M" ~ -1,  # Replace "male" with -1
    Sex == "F" ~ 1,  # Replace "female" with 1
  ))

# Incorporate the PC*Sex Interaction term
# Specify the number of PCs from the mouse group
num_pcs <- PC_80_val  # The total number of PCs

# Loop to create new columns for sex interaction
for (i in 1:num_pcs) {
  col_name <- paste0("Sex_PC", i)  # Create a new column name with PC number
  T2D_AD_TCR_reg2 <- T2D_AD_TCR_reg2 %>%
    mutate(!!col_name := Sex * get(paste0("PC", i)))  # Perform the interaction multiplication
}
# Loop to create new columns for age interaction
for (i in 1:num_pcs) {
  col_name <- paste0("Age_PC", i)  # Create a new column name with PC number
  T2D_AD_TCR_reg2 <- T2D_AD_TCR_reg2 %>%
    mutate(!!col_name := Age * get(paste0("PC", i)))  # Perform the interaction multiplication
}
```

## 4.5 LASSO and PC Selection
```{r Cross Validation with PC with Sex and Age, and Sex*PC and Age*PC Interactions}
set.seed(1)
# Number of repeats
num_repeats <- 20
# Initialize list to store coefficients
coefs_list_all_int2 <- list()

# Repeat the process
for (i in 1:num_repeats) {
    # Define response variable
    y_all_int2 <- T2D_AD_TCR_reg2$Condition
    # Define matrix of predictor variables
    x_all_int2 <- data.matrix(T2D_AD_TCR_reg2[c(3:ncol(T2D_AD_TCR_reg2))])
    # Perform 10-fold cross-validation to find optimal lambda value
    cv_model_all_int2 <- cv.glmnet(x_all_int2, y_all_int2, alpha = 1, grouped = FALSE, family = "binomial", type.measure = "class", nfolds = 10, maxit = 1000000)
    # Find optimal lambda value that minimizes test MSE
    best_lambda_all_int2 <- cv_model_all_int2$lambda.min
    #cat(sprintf("Repeat %d: The lambda value is: %f\n", i, best_lambda_all_int))
    # Find coefficients of best model
    best_model_all_int2 <- glmnet(x_all_int2, y_all_int2, alpha = 1, lambda = best_lambda_all_int2, nfolds = 10, family = "binomial", type.measure = "class", maxit = 1000000)
    # Store coefficients for each repetition of the model
    coefs_list_all_int2[[i]] <- as.vector(coef(best_model_all_int2))
}

# Convert coefficients list to data frame
coefs_lasso_all_int2 <- as.data.frame(do.call(cbind, coefs_list_all_int2))
# Replace the column name to represent each iteration re-run of the LASSO model
colnames(coefs_lasso_all_int2) <- sub("^V", "Iter", colnames(coefs_lasso_all_int2))
# Count non-zero coefficients in each row
coefs_lasso_all_int2$non_zero_count <- rowSums(coefs_lasso_all_int2 != 0)
# Mark as TRUE in a new column if greater than 4 non-zero counts
coefs_lasso_all_int2$variable_selection <- coefs_lasso_all_int2$non_zero_count > 4
# Include row names of the coefficients
rownames(coefs_lasso_all_int2) <- c("Intercept", colnames(x_all_int2))
# Pull out the count for number of non-zero coefficients
count_lasso_all_int2 <- coefs_lasso_all_int2[c("non_zero_count","variable_selection")]
# Move the row names to be in the first column
count_lasso_all_int2 <- tibble::rownames_to_column(count_lasso_all_int2)
colnames(count_lasso_all_int2)[1] <- "Variables"

# Reorder the row names
desired_order <- c("Sex", "Age", "PC1", "PC2", "PC3", "PC4", "PC5",
                   "PC6", "PC7", "PC8", "PC9", "PC10",
                   "PC11", "PC12", "PC13", 
                   "Sex_PC1", "Sex_PC2", "Sex_PC3", "Sex_PC4", "Sex_PC5",
                   "Sex_PC6", "Sex_PC7", "Sex_PC8", "Sex_PC9", "Sex_PC10",
                   "Sex_PC11", "Sex_PC12", "Sex_PC13",
                   "Age_PC1", "Age_PC2", "Age_PC3", "Age_PC4", "Age_PC5",
                   "Age_PC6", "Age_PC7", "Age_PC8", "Age_PC9", "Age_PC10",
                   "Age_PC11", "Age_PC12", "Age_PC13")

count_lasso_all_int2$Variables <- factor(count_lasso_all_int2$Variables, levels = count_lasso_all_int2$Var)

# Remove the intercept from the bar graph
count_lasso_all_int_plot2 <- count_lasso_all_int2[-1, ]

# Create color vector based on variable_selection
colors <- ifelse(count_lasso_all_int2$variable_selection == TRUE, "#7D7D7D","orange")

# Create the bar plot
ggplot(count_lasso_all_int_plot2, aes(x = reorder(Variables, -match(Variables, desired_order)), y = non_zero_count, fill = variable_selection)) +
  geom_bar(stat = "identity", color = "black", linewidth = 0.2) +
  scale_fill_manual(values = colors) +
  labs(x = "Variables",
       y = "Non-Zero Count") +
  theme(axis.text.y = element_text(size = 12)) +
  coord_flip() + theme_classic() + geom_hline(yintercept = 5, linetype = "dashed", color = "black") +
  scale_y_continuous(expand = expansion(mult = c(0, 0.01)))  # Adjust the limits of y-axis
```

```{r Non-Zero LASSO Coefficient Frequency of Model with PC, Sex*PC, and Age*PC}
count_lasso_all_int_plot2$Variables <- as.character(count_lasso_all_int_plot2$Variables)
# Remove the sex and age only terms for the heatmap purpose
count_lasso_all_int_plot2 <- count_lasso_all_int_plot2[grepl("PC", count_lasso_all_int_plot2$Variables), ]

# Pull out individual PCs without interaction terms
lasso_counts_all_int_noInt2 <- count_lasso_all_int_plot2[!grepl("Sex|Age", count_lasso_all_int_plot2$Variables), ]
# Pull out individual PCs related to Sex interaction
lasso_counts_all_int_Sex2 <- count_lasso_all_int_plot2[grepl("Sex", count_lasso_all_int_plot2$Variables), ]
# Pull out individual PCs related to Age interaction
lasso_counts_all_int_Age2 <- count_lasso_all_int_plot2[grepl("Age", count_lasso_all_int_plot2$Variables), ]

# Combine the frequencies into a new data frame
lasso_counts_all_int2 <- as.data.frame(cbind(lasso_counts_all_int_noInt2$non_zero_count, lasso_counts_all_int_Sex2$non_zero_count, lasso_counts_all_int_Age2$non_zero_count))
colnames(lasso_counts_all_int2)[1] <- "PC"
colnames(lasso_counts_all_int2)[2] <- "PC*Sex"
colnames(lasso_counts_all_int2)[3] <- "PC*Age"

# Set the row names of the matrix with respective PC number
row_labels <- 1:13
rownames(lasso_counts_all_int2) <- paste(row_labels, rownames(lasso_counts_all_int2), sep = " ")
lasso_counts_all_int_map2 <- lasso_counts_all_int2
# Convert to matrix format for the heatmap
lasso_counts_all_int_matrix2 <- as.matrix(lasso_counts_all_int_map2)

#svg('LASSO_ADCohort2.svg', width = 2, height = 4)
# Generate the heatmap for the PCs from the LASSO model
heatmapfig2 <- pheatmap(lasso_counts_all_int_matrix2,
  cluster_rows = FALSE,
  cluster_cols = FALSE,
  color = colorRampPalette(c("white", "orange"))(21),
  border_color = "black",
  breaks = seq(0, 20, length.out = 21),
  angle_col = 90,
  fontsize_col = 9,
  fontsize_row = 9,
  show_rownames = TRUE)
#dev.off()
```


```{r GLM Regression Modeling for PCs}
# GLM on selected PCs
model_list <- glm(Condition ~ PC2, data = T2D_AD_TCR_reg2, family = binomial, maxit=100)
summary(model_list)

model_list <- glm(Condition ~ PC5, data = T2D_AD_TCR_reg2, family = binomial, maxit=100)
summary(model_list)

model_list <- glm(Condition ~ PC6, data = T2D_AD_TCR_reg2, family = binomial, maxit=100)
summary(model_list)

model_list <- glm(Condition ~ PC9, data = T2D_AD_TCR_reg2, family = binomial, maxit=100)
summary(model_list)

model_list <- glm(Condition ~ PC10, data = T2D_AD_TCR_reg2, family = binomial, maxit=100)
summary(model_list)

model_list <- glm(Condition ~ PC11, data = T2D_AD_TCR_reg2, family = binomial, maxit=100)
summary(model_list)

model_list <- glm(Condition ~ PC12, data = T2D_AD_TCR_reg2, family = binomial, maxit=100)
summary(model_list)

model_list <- glm(Condition ~ PC13, data = T2D_AD_TCR_reg2, family = binomial, maxit=100)
summary(model_list)
```

## 4.6 Plot PCs Identified as Significant from TransComp-R and GLM
```{r PC2 and PC5}
#svg('PC2PC5_cohort2.svg', width = 4, height = 4)
# Create ggplot of the different PCs from TransComp-R
g2 <- ggplot(T2D_AD_TCR_reg2, aes(x = PC2, y = PC5, color = Condition)) + 
  geom_point(shape = 16, size = 1.0, color = "black") + 
  geom_point(size = 1.0) +
  scale_color_manual(values = c("#4575b4","#d73027")) +
  theme(legend.position = 'right') +
  coord_equal() 

# Factorize the Condition (AD vs Control)
g2$data$Condition <- as.factor(g2$data$Condition)

# Plot the figure
g2 +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
  theme_bw() +
  theme(
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank(),
    aspect.ratio = 1
  )
#dev.off()
```

```{r PC6 and PC11}
#svg('PC6PC11_cohort2.svg', width = 4, height = 4)
# Create ggplot of the different PCs from TransComp-R
g2 <- ggplot(T2D_AD_TCR_reg2, aes(x = PC6, y = PC11, color = Condition)) + 
  geom_point(shape = 16, size = 1.0, color = "black") + 
  geom_point(size = 1.0) +
  scale_color_manual(values = c("#4575b4","#d73027")) +
  theme(legend.position = 'right') +
  coord_equal() 

# Factorize the Condition (AD vs Control)
g2$data$Condition <- as.factor(g2$data$Condition)

# Plot the figure
g2 +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
  theme_bw() +
  theme(
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank(),
    aspect.ratio = 1
  )
#dev.off()
```

# 5 PERCENT VARIANCE EXPLAINED CALCULATIONS
## 5.1 T2D in Human Batch 1
```{r Percent Var Exp of T2D in Human Batch 1, warning=FALSE}
# Percent variance explained in human
ADVarExp <- lapply(1:ncol(Q_T2D), function(x) (t(Q_T2D[,x])%*%t(X_ADbatch1)%*%X_ADbatch1%*%Q_T2D[,x]) / (sum(diag(t(Q_T2D)%*%t(X_ADbatch1)%*%X_ADbatch1%*%Q_T2D))))
# Code does qi^T[X^T*X]qi / diag(Q^T*X^T*X*Q)

# Extract the mouse percent variance explained
T2DVarExp <- as.data.frame(cumVar)
T2DVarExp <- T2DVarExp %>%
  mutate(cumVar = ifelse(row_number() == 1, cumVar, cumVar - lag(cumVar)))
T2DVarExp <- T2DVarExp %>%
  slice(1:PC_80_val)

ADVarExp <- unlist(ADVarExp)
ADVarExp <- as.data.frame(ADVarExp)
# Combine the human and mouse percent variance explained
PCAvar <- cbind(T2DVarExp, ADVarExp)
PCAvar <- as.data.frame(PCAvar)
#PCAvar <- PCAvar[c(2,4)]
PCAvar <- rownames_to_column(PCAvar)
# Rename the columns to match respective information
colnames(PCAvar)[1] <- "PC"
colnames(PCAvar)[2] <- "T2D_PC"
colnames(PCAvar)[3] <- "AD_PC"
# Make the columns numeric
PCAvar$T2D_PC <- as.numeric(PCAvar$T2D_PC)
PCAvar$AD_PC <- as.numeric(PCAvar$AD_PC)
PCAvar$T2D_PC <- PCAvar$T2D_PC*100
PCAvar$AD_PC <- PCAvar$AD_PC*100


# Prepare the plot for mouse and human PC var explained
# Plot of the PCs
p1 <- ggplot(PCAvar, aes(x = AD_PC, y = T2D_PC)) +
  geom_point(color = "black", size = 2.0) +  # Change point color and size
  labs(title = "PCA",
       x = "Percent Variance Explained in AD Human by T2D",
       y = "Percent Variance Explained in T2D Human") +
  theme_bw() + theme(panel.grid=element_blank()) + scale_x_continuous(limits = c(0, 50)) + scale_y_continuous(limits = c(0, 50)) 

#svg('PercentVarExp_cohort1.svg', width = 4, height = 4)
# Plot to identify the PCs in the scatter plot space
ggplot(PCAvar, aes(x = AD_PC, y = T2D_PC, label = PC)) +
  geom_point(color = "black", size = 2.0) +
  geom_text(hjust = 0, vjust = 0, size = 3) +
  labs(title = "PCA",
       x = "Percent Variance Explained in AD Human by T2D",
       y = "Percent Variance Explained in T2D Human") +
  theme_bw() + theme(panel.grid = element_blank()) +
  scale_x_continuous(limits = c(0, 50)) +
  scale_y_continuous(limits = c(0, 50)) + 
  theme(aspect.ratio=1)
#dev.off()

#svg('PercentVarExpZoom_cohort1.svg', width = 4, height = 4)
# Zoom-in on the low variance section cluster
ggplot(PCAvar, aes(x = AD_PC, y = T2D_PC, label = PC)) +
  geom_point(color = "black", size = 2.5) +
  geom_text(hjust = 0, vjust = 0, size = 3) +
  labs(title = "PCA",
       x = "Percent Variance Explained in AD Human by T2D",
       y = "Percent Variance Explained in T2D Human") +
  theme_bw() + theme(panel.grid = element_blank()) +
  scale_x_continuous(limits = c(0, 1.5)) +
  scale_y_continuous(limits = c(0, 6)) + 
  theme(aspect.ratio=1)
#dev.off()
```

## 5.2 T2D in Human Batch 2
```{r Percent Var Exp of T2D in Human Batch 2, warning=FALSE}
# Percent variance explained in human
ADVarExp2 <- lapply(1:ncol(Q_T2D), function(x) (t(Q_T2D[,x])%*%t(X_ADbatch2)%*%X_ADbatch2%*%Q_T2D[,x]) / (sum(diag(t(Q_T2D)%*%t(X_ADbatch2)%*%X_ADbatch2%*%Q_T2D))))
# Code does qi^T[X^T*X]qi / diag(Q^T*X^T*X*Q)

# Extract the mouse percent variance explained
T2DVarExp <- as.data.frame(cumVar)
T2DVarExp <- T2DVarExp %>%
  mutate(cumVar = ifelse(row_number() == 1, cumVar, cumVar - lag(cumVar)))
T2DVarExp <- T2DVarExp %>%
  slice(1:PC_80_val)

ADVarExp2 <- unlist(ADVarExp2)
ADVarExp2 <- as.data.frame(ADVarExp2)
# Combine the human and mouse percent variance explained
PCAvar2 <- cbind(T2DVarExp, ADVarExp2)
PCAvar2 <- as.data.frame(PCAvar2)
PCAvar2 <- rownames_to_column(PCAvar2)
# Rename the columns to match respective information
colnames(PCAvar2)[1] <- "PC"
colnames(PCAvar2)[2] <- "T2D_PC"
colnames(PCAvar2)[3] <- "AD_PC"
# Make the columns numeric
PCAvar2$T2D_PC <- as.numeric(PCAvar2$T2D_PC)
PCAvar2$AD_PC <- as.numeric(PCAvar2$AD_PC)
PCAvar2$T2D_PC <- PCAvar2$T2D_PC*100
PCAvar2$AD_PC <- PCAvar2$AD_PC*100

# Prepare the plot for mouse and human PC var explained
# Plot of the PCs
p2 <- ggplot(PCAvar2, aes(x = AD_PC, y = T2D_PC)) +
  geom_point(color = "black", size = 2.5) +  # Change point color and size
  labs(title = "PCA",
       x = "Percent Variance Explained in AD Human by T2D",
       y = "Percent Variance Explained in T2D Human") +
  theme_bw() + theme(panel.grid=element_blank()) + scale_x_continuous(limits = c(0, 50)) + scale_y_continuous(limits = c(0, 50)) 

#svg('PercentVarExp_cohort2.svg', width = 4, height = 4)
# Plot to identify the PCs in the scatter plot space
ggplot(PCAvar2, aes(x = AD_PC, y = T2D_PC, label = PC)) +
  geom_point(color = "black", size = 2.5) +
  geom_text(hjust = 0, vjust = 0, size = 2) +
  labs(title = "PCA",
       x = "Percent Variance Explained in AD Human by T2D",
       y = "Percent Variance Explained in T2D Human") +
  theme_bw() + theme(panel.grid = element_blank()) +
  scale_x_continuous(limits = c(0, 50)) +
  scale_y_continuous(limits = c(0, 50)) + 
  theme(aspect.ratio =1)
#dev.off()

#svg('PercentVarExpZoom_cohort2.svg', width = 4, height = 4)
# Zoom-in on the low variance section cluster
ggplot(PCAvar2, aes(x = AD_PC, y = T2D_PC, label = PC)) +
  geom_point(color = "black", size = 2.5) +
  geom_text(hjust = 0, vjust = 0, size = 3) +
  labs(title = "PCA",
       x = "Percent Variance Explained in AD Human by T2D",
       y = "Percent Variance Explained in T2D Human") +
  theme_bw() + theme(panel.grid = element_blank()) +
  scale_x_continuous(limits = c(0, 1.5)) +
  scale_y_continuous(limits = c(0, 6)) + 
  theme(aspect.ratio=1)
#dev.off()
```

# 6 GENE SET ENRICHMENT ANALYSIS
## 6.1 KEGG Pathway
```{r GENE SET ENRICHMENT ANALYSIS - KEGG PATHWAY}
# SET THE DESIRED ORGANISM HERE
organism <- "org.Hs.eg.db"
# Prepare the dataset to be used for GSEA (KEGG)
hs_KEGG_sets <- msigdbr(species = "Homo sapiens",
                        category = "C2", subcategory = "CP:KEGG"
                       )

# Move the row names to be in the first column
Q_T2D_GSE <- as.data.frame(Q_T2D)
Q_T2D_GSE <- tibble::rownames_to_column(Q_T2D_GSE)
colnames(Q_T2D_GSE)[1] <- "genelist"
# Prepare a list of PC column names that will be used in the for loop
pc_columns <- grep("PC", colnames(Q_T2D_GSE), value = TRUE)
# Create an empty list to store GSEA results for each PC
gsea_results_list <- list()

# GSEA Analysis - For Loop for All PCs
for (pc_col in pc_columns) {
  # Extract gene list for each of the current PC through the for loop
  gene_list <- Q_T2D_GSE[, c("genelist", pc_col)]
  # Sort gene list by values of the loading scores
  gene_list <- gene_list %>% arrange(desc(!!sym(pc_col)))
  # Extract PC values for GSEA analysis
  pc_gene_list <- gene_list[[pc_col]]
  names(pc_gene_list) <- gene_list$genelist
  # Run the GSEA analysis
  gsea_results <- GSEA(
    geneList = pc_gene_list,
    minGSSize = 5,
    maxGSSize = 500,
    pvalueCutoff = 0.8, # Higher cutoff for visualization, but not all used
    eps = 0,
    seed = TRUE,
    pAdjustMethod = "BH", # Benjamini-Hochberg correction factor
    TERM2GENE = dplyr::select(hs_KEGG_sets, gs_name, gene_symbol)
  )
  # Store GSEA results in the list
  gsea_results_list[[pc_col]] <- data.frame(gsea_results@result)
}
# Save for kegg pathway
kegg_gsea_results_list <- gsea_results_list
# Save the GSEA File 
#write.xlsx(kegg_gsea_results_list, "GSEA_KEGG_T2Dhuman-to-human.xlsx")
```

```{r KEGG Results PC2, fig.height=6}
# T2D_PC2 KEGG 
#svg('T2D_PC2_KEGG.svg', width = 8, height = 8)
# Select the T2D_PC2 GSEA results
T2D_PC2_KEGG <- kegg_gsea_results_list$PC2
# Remove the Data Below FDR of 0.01 (0.01 is considered the level of significance)
T2D_PC2_KEGG  <- T2D_PC2_KEGG [with(T2D_PC2_KEGG , !((p.adjust >= 0.01))), ]
Proc_T2D_PC2_KEGG <- T2D_PC2_KEGG %>% mutate(sign = NES <= 0)

# Adjust the positions on the bar chart to display bars from lowest NES value to largest value
arranged_position <- arrange(Proc_T2D_PC2_KEGG, desc(NES))
# Pull out the positions for the enrichment plot
positions <- arranged_position$Description

# Creating the horizontal bar plots
ggplot(Proc_T2D_PC2_KEGG) +
  geom_col(aes(x = NES, y = Description, fill=sign), colour = "black", width = 0.9, alpha = 1) + 
  ylab(NULL) + xlab("Normalized Enrichment Score") + theme_minimal() + 
  theme(legend.position = "none", text=element_text(color="black", size = 2), 
        axis.text = element_text(color = "black", size=10)) + theme_classic() + 
geom_vline(xintercept = 0, color = "black", linetype = "solid", linewidth = 1.5) +
  xlim(c(-4.5,4.5)) + scale_y_discrete(limits = positions) + scale_fill_manual(values = c("royalblue", "royalblue"))
#dev.off()
```

```{r Gene Size Contribution to Pathway - KEGG}
# Convert the number of genes to a size value for the circe plot
compute_size <- function(setSize, size_breaks = c(50, 100, 150, 200, 250), size_values = c(1, 2, 3, 4, 5)) {
  size <- approx(size_breaks, size_values, xout = setSize, rule = 2)$y
  return(size)
}

# Apply the function to compute sizes
Proc_T2D_PC2_KEGG$computedSize <- compute_size(Proc_T2D_PC2_KEGG$setSize)

# Create the ggplot object
#svg('T2D_PC2_KEGGgenesize.svg', width = 8, height = 8)
p <- ggplot(Proc_T2D_PC2_KEGG, aes(x = 0, y = reorder(Description, NES)))
p + geom_point(color = "black", aes(size = computedSize)) +
    theme(axis.title.x = element_blank(),  
          axis.text.x = element_blank(),   
          axis.ticks.x = element_blank(),  
          axis.title.y = element_blank(),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank()) + 
    theme_bw() + 
    scale_x_continuous(expand = expansion(mult = c(0, 0))) +
    scale_y_discrete(limits = positions) + 
    scale_size_continuous(
      breaks = c(1, 2, 3, 4, 5),  
      labels = c("50", "100", "150", "200", "250")
    ) + labs(size = "Set Size")
#dev.off()
```

## 6.2 Hallmark Pathway
```{r GENE SET ENRICHMENT ANALYSIS - HALLMARK PATHWAY}
# SET THE DESIRED ORGANISM HERE
organism <- "org.Hs.eg.db"
# Prepare the dataset to be used for GSEA (HALLMARK)
hs_KEGG_sets <- msigdbr(species = "Homo sapiens",
                        category = "H"
                       )

# Move the row names to be in the first column
Q_T2D_GSE <- as.data.frame(Q_T2D)
Q_T2D_GSE <- tibble::rownames_to_column(Q_T2D_GSE)
colnames(Q_T2D_GSE)[1] <- "genelist"
# Prepare a list of PC column names that will be used in the for loop
pc_columns <- grep("PC", colnames(Q_T2D_GSE), value = TRUE)
# Create an empty list to store GSEA results for each PC
gsea_results_list <- list()

# GSEA Analysis - For Loop for All PCs
for (pc_col in pc_columns) {
  # Extract gene list for each of the current PC through the for loop
  gene_list <- Q_T2D_GSE[, c("genelist", pc_col)]
  # Sort gene list by values of the loading scores
  gene_list <- gene_list %>% arrange(desc(!!sym(pc_col)))
  # Extract PC values for GSEA analysis
  pc_gene_list <- gene_list[[pc_col]]
  names(pc_gene_list) <- gene_list$genelist
  # Run the GSEA analysis
  gsea_results <- GSEA(
    geneList = pc_gene_list,
    minGSSize = 5,
    maxGSSize = 500,
    pvalueCutoff = 0.8, # Higher cutoff for visualization, but not all used
    eps = 0,
    seed = TRUE,
    pAdjustMethod = "BH", # Benjamini-Hochberg correction factor
    TERM2GENE = dplyr::select(hs_KEGG_sets, gs_name, gene_symbol)
  )
  # Store GSEA results in the list
  gsea_results_list[[pc_col]] <- data.frame(gsea_results@result)
}
# Save for hallmark list
hallmark_gsea_results_list <- gsea_results_list
# Save the GSEA File 
#write.xlsx(hallmark_gsea_results_list, "GSEA_HALLMARK_T2Dhuman-to-human.xlsx")
```

```{r Hallmark Results PC2}
# T2D_PC2 HALLMARK
#svg('T2D_PC2_HALLMARK.svg', width = 8, height = 3.9)
# Select the T2D_PC2 GSEA results
T2D_PC2_HALLMARK <- hallmark_gsea_results_list$PC2
# Remove the Data Below FDR of 0.01 (0.01 is considered the level of significance)
T2D_PC2_HALLMARK  <- T2D_PC2_HALLMARK [with(T2D_PC2_HALLMARK , !((p.adjust >= 0.01))), ]
Proc_T2D_PC2_HALLMARK <- T2D_PC2_HALLMARK %>% mutate(sign = NES <= 0)
# Adjust the positions on the bar chart to display bars from lowest NES value to largest value
arranged_position <- arrange(Proc_T2D_PC2_HALLMARK, desc(NES))
# Pull out the positions for the enrichment plot
positions <- arranged_position$Description
# Creating the horizontal bar plots
ggplot(Proc_T2D_PC2_HALLMARK) +
  geom_col(aes(x = NES, y = Description, fill=sign), colour = "black", width = 0.8) + 
  ylab(NULL) + xlab("Normalized Enrichment Score") + theme_minimal() + 
  theme(legend.position = "none", text=element_text(color="black", size = 2), 
        axis.text = element_text(color = "black", size=10)) + theme_classic() + 
geom_vline(xintercept = 0, color = "black", linetype = "solid", linewidth = 1.5) +
  xlim(c(-4.5,4.5)) + scale_y_discrete(limits = positions) + scale_fill_manual(values = c("royalblue", "royalblue"))
#dev.off()
```

```{r Gene Size Contribution to Pathway - HALLMARK}
# Apply the function to compute sizes
Proc_T2D_PC2_HALLMARK$computedSize <- compute_size(Proc_T2D_PC2_HALLMARK$setSize)

# Create the ggplot object
#svg('T2D_PC2_HALLMARKgenesize.svg', width = 8, height = 3.9)
p <- ggplot(Proc_T2D_PC2_HALLMARK, aes(x = 0, y = reorder(Description, NES)))
p + geom_point(color = "black", aes(size = computedSize)) +
    theme(axis.title.x = element_blank(),  
          axis.text.x = element_blank(),   
          axis.ticks.x = element_blank(),  
          axis.title.y = element_blank(),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank()) + 
    theme_bw() + 
    scale_x_continuous(expand = expansion(mult = c(0, 0))) +
    scale_y_discrete(limits = positions) + 
    scale_size_continuous(
      breaks = c(1, 2, 3, 4, 5),
      labels = c("50", "100", "150", "200", "250")
    ) + labs(size = "Set Size")
#dev.off()
```

## 6.3 Shared Genes in Pathways
```{r KEGG Pathway}
# Prepare the gene and pathway data and separate the enrichment genes
KEGG_pathway_dat <- Proc_T2D_PC2_KEGG %>%
  select(Description, core_enrichment) %>%
  separate_rows(core_enrichment, sep = "/") %>%
  distinct()

# Create List of edges for shared genes
KEGG_edges <- KEGG_pathway_dat %>%
  inner_join(KEGG_pathway_dat, by = "core_enrichment") %>%
  filter(Description.x != Description.y) %>%
  group_by(Description.x, Description.y) %>%
  summarise(shared_genes = n(), .groups = 'drop') %>%
  ungroup()

# Ensure edges are unique for each pathway pair
KEGG_edges <- KEGG_edges %>%
  mutate(pair = ifelse(Description.x < Description.y,
                       paste(Description.x, Description.y, sep = "-"),
                       paste(Description.y, Description.x, sep = "-"))) %>%
  distinct(pair, .keep_all = TRUE) %>%
  select(Description.x, Description.y, shared_genes)

# Create a graph object
KEGG_graph <- igraph::graph_from_data_frame(KEGG_edges, directed = FALSE)
# Simplify the graph to avoid double edges
KEGG_graph <- igraph::simplify(KEGG_graph, remove.multiple = TRUE, remove.loops = TRUE)

# Convert to tbl_graph for use
KEGG_tbl_graph <- as_tbl_graph(KEGG_graph) %>%
  activate(edges) %>%
  mutate(shared_genes = KEGG_edges$shared_genes)

# Plot the network
ggraph(KEGG_tbl_graph, layout = 'fr') + 
  geom_edge_link(aes(width = shared_genes), alpha = 0.8, color = "blue") +
  geom_node_point(size = 3, color = "red") +
  geom_node_text(aes(label = name), repel = TRUE, size = 1) +
  scale_edge_width(range = c(0.2, 2)) +
  theme_void()
```

```{r Hallmark Pathway}
# Prepare the gene and pathway data and separate the enrichment genes
HALLMARK_pathway_dat <- Proc_T2D_PC2_HALLMARK %>%
  select(Description, core_enrichment) %>%
  separate_rows(core_enrichment, sep = "/") %>%
  distinct()

# Create List of edges for shared genes
HALLMARK_edges <- HALLMARK_pathway_dat %>%
  inner_join(HALLMARK_pathway_dat, by = "core_enrichment") %>%
  filter(Description.x != Description.y) %>%
  group_by(Description.x, Description.y) %>%
  summarise(shared_genes = n(), .groups = 'drop') %>%
  ungroup()

# Ensure edges are unique for each pathway pair
HALLMARK_edges <- HALLMARK_edges %>%
  mutate(pair = ifelse(Description.x < Description.y,
                       paste(Description.x, Description.y, sep = "-"),
                       paste(Description.y, Description.x, sep = "-"))) %>%
  distinct(pair, .keep_all = TRUE) %>%
  select(Description.x, Description.y, shared_genes)

# Create a graph object
HALLMARK_graph <- igraph::graph_from_data_frame(HALLMARK_edges, directed = FALSE)
# Simplify the graph to avoid double edges
HALLMARK_graph <- igraph::simplify(HALLMARK_graph, remove.multiple = TRUE, remove.loops = TRUE)

# Convert to tbl_graph for use
HALLMARK_tbl_graph <- as_tbl_graph(HALLMARK_graph) %>%
  activate(edges) %>%
  mutate(shared_genes = HALLMARK_edges$shared_genes)

# Plot the network
ggraph(HALLMARK_tbl_graph, layout = 'fr') + 
  geom_edge_link(aes(width = shared_genes), alpha = 0.8, color = "blue") +
  geom_node_point(size = 3, color = "red") +
  geom_node_text(aes(label = name), repel = TRUE, size = 1) +
  scale_edge_width(range = c(0.2, 2)) +
  theme_void()
```

```{r Export Edges of the Pathways}
# Export the edges for shared genes
#write.csv(KEGG_edges, "KEGG_pathway_edges.csv")
#write.csv(HALLMARK_edges, "HALLMARK_pathway_edges.csv")
```

# 7 SEX-BASED DIFFERENCES ACROSS PCs
## 7.1 Sex Interaction for PC2
### AD Cohort 1
```{r Dataframe Preparation}
# Prepare the data by sex and condition
T2D_AD_TCR_group <- T2D_AD_TCR %>%
  mutate(Sex.condition = paste(Sex, Condition, sep = "_")) %>%
  relocate(Sex.condition, .after = SubjectID)
```

```{r Sex Interaction Relationship in PC2}
# SEX/CONDITION COMPARISON ACROSS SCORES
#svg('PC2_Sex_cohort1.svg', width = 4, height = 4)
# Prepare color groups below
group_colors <- c("M_AD" = "black", "F_AD" = "black", "M_C" = "black", "F_C" = "black")
# Plot the different groups respective of sex and disease status
ggplot(T2D_AD_TCR_group, aes(x = Sex.condition, y = PC2, fill = Sex.condition)) +
  geom_jitter(shape = 21, width = 0.1, height = 0, size = 1, color = "black") + 
  geom_bar(stat = "identity", fill = "transparent", color = "transparent") +
  stat_summary(fun = mean, geom = "errorbar", aes(ymax = after_stat(y), ymin = after_stat(y)), width = 0.35, color = "red") +
  stat_summary(fun.data = function(y) {
    data.frame(ymin = quantile(y, 0.25), ymax = quantile(y, 0.75), y = mean(y))
  }, geom = "errorbar", width = 0.25, color = "red") +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
  scale_fill_manual(values = group_colors) +  # Set manual fill color scale
  coord_cartesian(ylim = c(-8000, 8000)) + 
  theme_bw() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        aspect.ratio = 1,
        legend.position="none") +
  labs(x = "Sex.condition", y = "PC2")
#dev.off()
```

```{r Mann Whitney with BH-Corrected Test Among Sex and Condition}
# Rename a new variable for the Mann-Whitney statistical analysis
T2D_AD_TCR_group_MW <- T2D_AD_TCR_group
# Establishing four different groups based disease condition and sex
# First establish a group for each sex/condition pair
F_Control <- T2D_AD_TCR_group_MW[grepl("F_C", T2D_AD_TCR_group_MW$Sex.condition),]
M_Control <- T2D_AD_TCR_group_MW[grepl("M_C", T2D_AD_TCR_group_MW$Sex.condition),]
F_AD <- T2D_AD_TCR_group_MW[grepl("F_AD", T2D_AD_TCR_group_MW$Sex.condition),]
M_AD <- T2D_AD_TCR_group_MW[grepl("M_AD", T2D_AD_TCR_group_MW$Sex.condition),]
# Calculate p-values for each pair
# Both_PC2 Mann Whitney Comparison
F_ControlvsM_Control <- wilcox.test(F_Control$PC2, M_Control$PC2, alternative = "two.sided")
F_ControlvsF_AD <- wilcox.test(F_Control$PC2, F_AD$PC2, alternative = "two.sided")
F_ControlvsM_AD <- wilcox.test(F_Control$PC2, M_AD$PC2, alternative = "two.sided")
M_ControlvsF_AD <- wilcox.test(M_Control$PC2, F_AD$PC2, alternative = "two.sided")
M_ControlvsM_AD <- wilcox.test(M_Control$PC2, M_AD$PC2, alternative = "two.sided")
F_ADvsM_AD <- wilcox.test(F_AD$PC2, M_AD$PC2,alternative = "two.sided")
# Create a list for the disease-sex pair relationships 
Pairwise <- c("F-Control vs M-Control", "F_Control vs F-AD", "F-Control vs M-AD", "M-Control vs F-AD", "M-Control vs M-AD", "F-AD vs M-AD")
# Prepare the pvalues in a list
PC2 <- c(F_ControlvsM_Control$p.value, F_ControlvsF_AD$p.value, F_ControlvsM_AD$p.value, M_ControlvsF_AD$p.value, M_ControlvsM_AD$p.value, F_ADvsM_AD$p.value)
# Generate Data frame for the MW test for Both_PC2
PC2_MW <- data.frame(Pairwise, PC2)
colnames(PC2_MW)[2] <- "pval"
# Perform Benjamini-Hochberg correction to account for multiple-testing
PC2_MW$adjFDR<- p.adjust(PC2_MW$pval, method = "BH")
```

```{r Mann Whitney with BH-Corrected Test Across Condition (Not Sex)}
# Rename a new variable for the Mann-Whitney statistical analysis
T2D_AD_TCR_group_MW_cond <- T2D_AD_TCR_group
# Establishing four different groups based disease condition and sex
# First establish a group for each sex/condition pair
cond_AD <- T2D_AD_TCR_group_MW_cond[grepl("AD", T2D_AD_TCR_group_MW_cond$Condition),]
cond_Control <- T2D_AD_TCR_group_MW_cond[grepl("C", T2D_AD_TCR_group_MW_cond$Condition),]

# Calculate p-values for each pair
# Both_PC2 Mann Whitney Comparison
ADvsC <- wilcox.test(cond_AD$PC2, cond_Control$PC2, alternative = "two.sided")

# Create a list for the disease-sex pair relationships 
Pairwise <- c("AD vs Control")
# Prepare the pvalues in a list
PC2 <- c(ADvsC$p.value)
# Generate Data frame for the MW test for Both_PC2
PC2_MW_cond <- data.frame(Pairwise, PC2)
colnames(PC2_MW_cond)[2] <- "pval"
# Perform Benjamini-Hochberg correction to account for multiple-testing
PC2_MW_cond$adjFDR<- p.adjust(PC2_MW_cond$pval, method = "BH")
```

### AD Cohort 2
```{r AD Cohort 2 Dataframe Preparation}
# Prepare the data by sex and condition
T2D_AD_TCR_group2 <- T2D_AD_TCR2 %>%
  mutate(Sex.condition = paste(Sex, Condition, sep = "_")) %>%
  relocate(Sex.condition, .after = SubjectID)
```

```{r Sex Interaction Relationship in PC2}
# SEX/CONDITION COMPARISON ACROSS SCORES
#svg('PC2_Sex_cohort2.svg', width = 4, height = 4)
# Prepare color groups below, which is shown in the graph
group_colors <- c("M_AD" = "black", "F_AD" = "black", "M_C" = "black", "F_C" = "black")
# Plot the different groups respective of sex and disease status
ggplot(T2D_AD_TCR_group2, aes(x = Sex.condition, y = PC2, fill = Sex.condition)) +
  geom_jitter(shape = 21, width = 0.1, height = 0, size = 1, color = "black") + 
  geom_bar(stat = "identity", fill = "transparent", color = "transparent") +
  stat_summary(fun = mean, geom = "errorbar", aes(ymax = after_stat(y), ymin = after_stat(y)), width = 0.35, color = "red") +
  stat_summary(fun.data = function(y) {
    data.frame(ymin = quantile(y, 0.25), ymax = quantile(y, 0.75), y = mean(y))
  }, geom = "errorbar", width = 0.25, color = "red") +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
  scale_fill_manual(values = group_colors) +  # Set manual fill color scale
  coord_cartesian(ylim = c(-8000, 8000)) + 
  theme_bw() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        aspect.ratio = 1,
        legend.position="none") +
  labs(x = "Sex.condition", y = "PC2")
#dev.off()
```

```{r Mann Whitney with BH-Corrected Test Among Sex and Condition}
# Rename a new variable for the Mann-Whitney statistical analysis
T2D_AD_TCR_group_MW2 <- T2D_AD_TCR_group2
# Establishing four different groups based disease condition and sex
# First establish a group for each sex/condition pair
F_Control <- T2D_AD_TCR_group_MW2[grepl("F_C", T2D_AD_TCR_group_MW2$Sex.condition),]
M_Control <- T2D_AD_TCR_group_MW2[grepl("M_C", T2D_AD_TCR_group_MW2$Sex.condition),]
F_AD <- T2D_AD_TCR_group_MW2[grepl("F_AD", T2D_AD_TCR_group_MW2$Sex.condition),]
M_AD <- T2D_AD_TCR_group_MW2[grepl("M_AD", T2D_AD_TCR_group_MW2$Sex.condition),]
# Calculate p-values for each pair
# Both_PC2 Mann Whitney Comparison
F_ControlvsM_Control <- wilcox.test(F_Control$PC2, M_Control$PC2, alternative = "two.sided")
F_ControlvsF_AD <- wilcox.test(F_Control$PC2, F_AD$PC2, alternative = "two.sided")
F_ControlvsM_AD <- wilcox.test(F_Control$PC2, M_AD$PC2, alternative = "two.sided")
M_ControlvsF_AD <- wilcox.test(M_Control$PC2, F_AD$PC2, alternative = "two.sided")
M_ControlvsM_AD <- wilcox.test(M_Control$PC2, M_AD$PC2, alternative = "two.sided")
F_ADvsM_AD <- wilcox.test(F_AD$PC2, M_AD$PC2,alternative = "two.sided")
# Create a list for the disease-sex pair relationships 
Pairwise <- c("F-Control vs M-Control", "F_Control vs F-AD", "F-Control vs M-AD", "M-Control vs F-AD", "M-Control vs M-AD", "F-AD vs M-AD")
# Prepare the pvalues in a list
PC2 <- c(F_ControlvsM_Control$p.value, F_ControlvsF_AD$p.value, F_ControlvsM_AD$p.value, M_ControlvsF_AD$p.value, M_ControlvsM_AD$p.value, F_ADvsM_AD$p.value)
# Generate Data frame for the MW test for Both_PC2
PC2_MW2 <- data.frame(Pairwise, PC2)
colnames(PC2_MW2)[2] <- "pval"
# Perform Benjamini-Hochberg correction to account for multiple-testing
PC2_MW2$adjFDR<- p.adjust(PC2_MW2$pval, method = "BH")
```

```{r Mann Whitney with BH-Corrected Test Across Condition (Not Sex)}
# Rename a new variable for the Mann-Whitney statistical analysis
T2D_AD_TCR_group_MW2_cond <- T2D_AD_TCR_group2
# Establishing four different groups based disease condition and sex
# First establish a group for each sex/condition pair
cond_AD <- T2D_AD_TCR_group_MW2_cond[grepl("AD", T2D_AD_TCR_group_MW2_cond$Condition),]
cond_Control <- T2D_AD_TCR_group_MW2_cond[grepl("C", T2D_AD_TCR_group_MW2_cond$Condition),]

# Calculate p-values for each pair
# Both_PC2 Mann Whitney Comparison
ADvsC <- wilcox.test(cond_AD$PC2, cond_Control$PC2, alternative = "two.sided")

# Create a list for the disease-sex pair relationships 
Pairwise <- c("AD vs Control")
# Prepare the pvalues in a list
PC2 <- c(ADvsC$p.value)
# Generate Data frame for the MW2 test for Both_PC2
PC2_MW2_cond <- data.frame(Pairwise, PC2)
colnames(PC2_MW2_cond)[2] <- "pval"
# Perform Benjamini-Hochberg correction to account for multiple-testing
PC2_MW2_cond$adjFDR<- p.adjust(PC2_MW2_cond$pval, method = "BH")
```

# 8 LOG2 FOLD CHANGE CALCULATIONS
```{r Log2FC Calculations}
# Identify the range of columns for the genes
gene_columns_T2D <- colnames(X_T2Ddat_NN)[7:ncol(X_T2Ddat_NN)]
# Create a new dataframe with the average of each gene separated by Condition
X_T2Ddat_NN_base2 <- X_T2Ddat_NN
X_T2Ddat_NN_base2[, 7:ncol(X_T2Ddat_NN)] <- 2^(X_T2Ddat_NN[, 7:ncol(X_T2Ddat_NN)])

X_T2Ddat_avg <- X_T2Ddat_NN_base2 %>%
  group_by(Condition) %>%
  summarise(across(all_of(gene_columns_T2D), \(x) mean(x, na.rm = TRUE))) %>%
  select(Condition, all_of(gene_columns_T2D))
# Extract T2D and C rows
T2D_row <- X_T2Ddat_avg %>% filter(Condition == "T2D")
C_row <- X_T2Ddat_avg %>% filter(Condition == "C")

# Calculate log2 fold change for each gene
T2D_log2_fc <- log2(as.numeric(T2D_row[1, -1]) / as.numeric(C_row[1, -1]))
# Create a new row for log2 fold change
T2D_new_row <- c("T2D_log2_FC", T2D_log2_fc)
# Add the new row to the dataframe
X_T2Ddat_avg <- rbind(X_T2Ddat_avg, T2D_new_row)

# Identify the range of columns for the genes
gene_columns_AD1 <- colnames(X_batch1dat_NN)[5:ncol(X_batch1dat_NN)]

X_batch1dat_NN_base2 <- X_batch1dat_NN
X_batch1dat_NN_base2[, 5:ncol(X_batch1dat_NN)] <- 2^(X_batch1dat_NN[, 5:ncol(X_batch1dat_NN)])

# Create a new dataframe with the average of each gene separated by Condition
X_batch1dat_avg <- X_batch1dat_NN_base2 %>%
  group_by(Condition) %>%
  summarise(across(all_of(gene_columns_AD1), \(x) mean(x, na.rm = TRUE))) %>%
  select(Condition, all_of(gene_columns_AD1))
# Extract AD and C rows
AD_row <- X_batch1dat_avg %>% filter(Condition == "AD")
C_row <- X_batch1dat_avg %>% filter(Condition == "C")

# Calculate log2 fold change for each gene
AD1_log2_fc <- log2(as.numeric(AD_row[1, -1]) / as.numeric(C_row[1, -1]))
# Create a new row for log2 fold change
AD1_new_row <- c("AD1_log2_FC", AD1_log2_fc)
# Add the new row to the dataframe
X_batch1dat_avg <- rbind(X_batch1dat_avg, AD1_new_row)

# Identify the range of columns for the genes
gene_columns_AD2 <- colnames(X_batch2dat_NN)[5:ncol(X_batch2dat_NN)]

X_batch2dat_NN_base2 <- X_batch2dat_NN
X_batch2dat_NN_base2[, 5:ncol(X_batch2dat_NN)] <- 2^(X_batch2dat_NN[, 5:ncol(X_batch2dat_NN)])

# Create a new dataframe with the average of each gene separated by Condition
X_batch2dat_avg <- X_batch2dat_NN_base2 %>%
  group_by(Condition) %>%
  summarise(across(all_of(gene_columns_AD2), \(x) mean(x, na.rm = TRUE))) %>%
  select(Condition, all_of(gene_columns_AD2))
# Extract AD and C rows
AD_row <- X_batch2dat_avg %>% filter(Condition == "AD")
C_row <- X_batch2dat_avg %>% filter(Condition == "C")
# Calculate log2 fold change for each gene
AD2_log2_fc <- log2(as.numeric(AD_row[1, -1]) / as.numeric(C_row[1, -1]))
# Create a new row for log2 fold change
AD2_new_row <- c("AD2_log2_FC", AD2_log2_fc)
# Add the new row to the dataframe
X_batch2dat_avg <- rbind(X_batch2dat_avg, AD2_new_row)
```

## 8.1 Plot Between AD1 and T2D Log2FC
```{r Plot Log2FC with AD1 and T2D}
# Combine AD1 and T2D
AD1_T2D_fc <- rbind(X_batch1dat_avg, X_T2Ddat_avg)
# Select only log2FC rows
AD1_T2D_fc <- AD1_T2D_fc[grepl("FC", AD1_T2D_fc$Condition), ]
AD1_T2D_fc <- as.data.frame(AD1_T2D_fc)
# Set the genes as the row names
rownames(AD1_T2D_fc) <- AD1_T2D_fc$Condition
AD1_T2D_fc <- AD1_T2D_fc[, -1]
# Take the transpose
AD1_T2D_fc <- t(AD1_T2D_fc)

# Plot with gene labels
ggplot(AD1_T2D_fc, aes(x = AD1_log2_fc, y = T2D_log2_fc, label = rownames(AD1_T2D_fc))) +
  geom_point(size=1) +
  geom_text(aes(label = ifelse(T2D_log2_fc > 2, rownames(AD1_T2D_fc), "")), 
            vjust = -0.5, hjust = 0.5, size = 3) +
  geom_text(aes(label = ifelse(T2D_log2_fc < -1, rownames(AD1_T2D_fc), "")), 
            vjust = -0.5, hjust = 0.5, size = 3) +
  geom_text(aes(label = ifelse(AD1_log2_fc > 0.04, rownames(AD1_T2D_fc), "")), 
            vjust = -0.5, hjust = 0.5, size = 3) +
  geom_text(aes(label = ifelse(AD1_log2_fc < -0.10, rownames(AD1_T2D_fc), "")), 
            vjust = -0.5, hjust = 0.5, size = 3) +
  labs(x = "AD1_log2_fc",
       y = "T2D_log2_fc") +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
  theme_bw() +
    theme(
    panel.grid.major = element_blank(),  # Remove major gridlines
    panel.grid.minor = element_blank(),
    aspect.ratio = 1# Remove minor gridlines
  )
# Plot without labels
#svg('T2D_AD1_log2fc.svg', width = 4, height = 4)
ggplot(AD1_T2D_fc, aes(x = AD1_log2_fc, y = T2D_log2_fc, label = rownames(AD1_T2D_fc))) +
  geom_point(size=1) +
  labs(x = "AD1_log2_fc",
       y = "T2D_log2_fc") +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
  theme_bw() +
    theme(
    panel.grid.major = element_blank(),  # Remove major gridlines
    panel.grid.minor = element_blank(),
    aspect.ratio = 1# Remove minor gridlines
  )
#dev.off()
```

```{r Gene Labels for AD Cohort 1 Plot}
# Gene Labeling of Different Areas of AD1 Graph
ggplot(AD1_T2D_fc, aes(x = AD1_log2_fc, y = T2D_log2_fc)) +
  geom_point(size=1) +
  geom_text_repel(aes(label = ifelse(AD1_log2_fc > -1.2 & AD1_log2_fc < -0.8 & T2D_log2_fc > -2.5 & T2D_log2_fc < -0.15, rownames(AD1_T2D_fc), "")), 
                  size = 2, 
                  max.overlaps = Inf) +  # Increase the max overlaps
  labs(x = "AD1_log2_fc",
       y = "T2D_log2_fc") +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
  theme_bw() +
  theme(
    panel.grid.major = element_blank(),  # Remove major gridlines
    panel.grid.minor = element_blank(),  # Remove minor gridlines
    aspect.ratio=1
  )

# Gene Labeling of Different Areas of AD1 Graph
ggplot(AD1_T2D_fc, aes(x = AD1_log2_fc, y = T2D_log2_fc)) +
  geom_point(size=1) +
  geom_text_repel(aes(label = ifelse(AD1_log2_fc > -1.2 & AD1_log2_fc < -1.0 & T2D_log2_fc > -2.5 & T2D_log2_fc < -0.15, rownames(AD1_T2D_fc), "")), 
                  size = 2, 
                  max.overlaps = Inf) +  # Increase the max overlaps
  labs(x = "AD1_log2_fc",
       y = "T2D_log2_fc") +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
  theme_bw() +
  theme(
    panel.grid.major = element_blank(),  # Remove major gridlines
    panel.grid.minor = element_blank(),  # Remove minor gridlines
    aspect.ratio=1
  )

# Gene Labeling of Different Areas of AD1 Graph
ggplot(AD1_T2D_fc, aes(x = AD1_log2_fc, y = T2D_log2_fc)) +
  geom_point(size=1) +
  geom_text_repel(aes(label = ifelse(AD1_log2_fc > -1.0 & AD1_log2_fc < -0.8 & T2D_log2_fc > -2.5 & T2D_log2_fc < -0.15, rownames(AD1_T2D_fc), "")), 
                  size = 2, 
                  max.overlaps = Inf) +  # Increase the max overlaps
  labs(x = "AD1_log2_fc",
       y = "T2D_log2_fc") +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
  theme_bw() +
  theme(
    panel.grid.major = element_blank(),  # Remove major gridlines
    panel.grid.minor = element_blank(),  # Remove minor gridlines
    aspect.ratio=1
  )

# Gene Labeling of Different Areas of AD1 Graph
ggplot(AD1_T2D_fc, aes(x = AD1_log2_fc, y = T2D_log2_fc)) +
  geom_point(size=1) +
  geom_text_repel(aes(label = ifelse(AD1_log2_fc > -0.8 & AD1_log2_fc < -0.7 & T2D_log2_fc > -2.5 & T2D_log2_fc < -0.15, rownames(AD1_T2D_fc), "")), 
                  size = 2, 
                  max.overlaps = Inf) +  # Increase the max overlaps
  labs(x = "AD1_log2_fc",
       y = "T2D_log2_fc") +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
  theme_bw() +
  theme(
    panel.grid.major = element_blank(),  # Remove major gridlines
    panel.grid.minor = element_blank(),  # Remove minor gridlines
    aspect.ratio=1
  )

# Gene Labeling of Different Areas of AD1 Graph
ggplot(AD1_T2D_fc, aes(x = AD1_log2_fc, y = T2D_log2_fc)) +
  geom_point(size=1) +
  geom_text_repel(aes(label = ifelse(AD1_log2_fc > -0.7 & AD1_log2_fc < -0.65 & T2D_log2_fc > -2 & T2D_log2_fc < -0.15, rownames(AD1_T2D_fc), "")), 
                  size = 2, 
                  max.overlaps = Inf) +  # Increase the max overlaps
  labs(x = "AD1_log2_fc",
       y = "T2D_log2_fc") +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
  theme_bw() +
  theme(
    panel.grid.major = element_blank(),  # Remove major gridlines
    panel.grid.minor = element_blank(),  # Remove minor gridlines
    aspect.ratio=1
  )

# Gene Labeling of Different Areas of AD1 Graph
ggplot(AD1_T2D_fc, aes(x = AD1_log2_fc, y = T2D_log2_fc)) +
  geom_point(size=1) +
  geom_text_repel(aes(label = ifelse(AD1_log2_fc > -0.65 & AD1_log2_fc < -2 & T2D_log2_fc > -2 & T2D_log2_fc < -0.15, rownames(AD1_T2D_fc), "")), 
                  size = 2, 
                  max.overlaps = Inf) +  # Increase the max overlaps
  labs(x = "AD1_log2_fc",
       y = "T2D_log2_fc") +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
  theme_bw() +
  theme(
    panel.grid.major = element_blank(),  # Remove major gridlines
    panel.grid.minor = element_blank(),  # Remove minor gridlines
    aspect.ratio=1
  )

# Gene Labeling of Different Areas of AD1 Graph
ggplot(AD1_T2D_fc, aes(x = AD1_log2_fc, y = T2D_log2_fc)) +
  geom_point(size=1) +
  geom_text_repel(aes(label = ifelse(AD1_log2_fc > -0.6 & AD1_log2_fc < -0.5 & T2D_log2_fc > -2 & T2D_log2_fc < -0.15, rownames(AD1_T2D_fc), "")), 
                  size = 2, 
                  max.overlaps = Inf) +  # Increase the max overlaps
  labs(x = "AD1_log2_fc",
       y = "T2D_log2_fc") +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
  theme_bw() +
  theme(
    panel.grid.major = element_blank(),  # Remove major gridlines
    panel.grid.minor = element_blank(),  # Remove minor gridlines
    aspect.ratio=1
  )

# Gene Labeling of Different Areas of AD1 Graph
ggplot(AD1_T2D_fc, aes(x = AD1_log2_fc, y = T2D_log2_fc)) +
  geom_point(size=1) +
  geom_text_repel(aes(label = ifelse(AD1_log2_fc > -0.8 & AD1_log2_fc < -0.1 & T2D_log2_fc > -0.1 & T2D_log2_fc < 2.5, rownames(AD1_T2D_fc), "")), 
                  size = 2, 
                  max.overlaps = Inf) +  # Increase the max overlaps
  labs(x = "AD1_log2_fc",
       y = "T2D_log2_fc") +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
  theme_bw() +
  theme(
    panel.grid.major = element_blank(),  # Remove major gridlines
    panel.grid.minor = element_blank(),  # Remove minor gridlines
    aspect.ratio=1
  )

# Gene Labeling of Different Areas of AD1 Graph
ggplot(AD1_T2D_fc, aes(x = AD1_log2_fc, y = T2D_log2_fc)) +
  geom_point(size=1) +
  geom_text_repel(aes(label = ifelse(AD1_log2_fc > -0.3 & AD1_log2_fc < -0.1 & T2D_log2_fc > 0 & T2D_log2_fc < 2.5, rownames(AD1_T2D_fc), "")), 
                  size = 2, 
                  max.overlaps = Inf) +  # Increase the max overlaps
  labs(x = "AD1_log2_fc",
       y = "T2D_log2_fc") +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
  theme_bw() +
  theme(
    panel.grid.major = element_blank(),  # Remove major gridlines
    panel.grid.minor = element_blank(),  # Remove minor gridlines
    aspect.ratio=1
  )

# Gene Labeling of Different Areas of AD1 Graph
ggplot(AD1_T2D_fc, aes(x = AD1_log2_fc, y = T2D_log2_fc)) +
  geom_point(size=1) +
  geom_text_repel(aes(label = ifelse(AD1_log2_fc > -0.1 & AD1_log2_fc < 0.1 & T2D_log2_fc > 1.8 & T2D_log2_fc < 2.5, rownames(AD1_T2D_fc), "")), 
                  size = 2, 
                  max.overlaps = Inf) +  # Increase the max overlaps
  labs(x = "AD1_log2_fc",
       y = "T2D_log2_fc") +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
  theme_bw() +
  theme(
    panel.grid.major = element_blank(),  # Remove major gridlines
    panel.grid.minor = element_blank(),  # Remove minor gridlines
    aspect.ratio=1
  )

# Gene Labeling of Different Areas of AD1 Graph
ggplot(AD1_T2D_fc, aes(x = AD1_log2_fc, y = T2D_log2_fc)) +
  geom_point(size=1) +
  geom_text_repel(aes(label = ifelse(AD1_log2_fc > 0.25 & AD1_log2_fc < 0.45 & T2D_log2_fc > 0.0 & T2D_log2_fc < 2, rownames(AD1_T2D_fc), "")), 
                  size = 2, 
                  max.overlaps = Inf) +  # Increase the max overlaps
  labs(x = "AD1_log2_fc",
       y = "T2D_log2_fc") +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
  theme_bw() +
  theme(
    panel.grid.major = element_blank(),  # Remove major gridlines
    panel.grid.minor = element_blank(),  # Remove minor gridlines
    aspect.ratio=1
  )

# Gene Labeling of Different Areas of AD1 Graph
ggplot(AD1_T2D_fc, aes(x = AD1_log2_fc, y = T2D_log2_fc)) +
  geom_point(size=1) +
  geom_text_repel(aes(label = ifelse(AD1_log2_fc > -0.1 & AD1_log2_fc < 0.3 & T2D_log2_fc > -3 & T2D_log2_fc < -1.4, rownames(AD1_T2D_fc), "")), 
                  size = 2, 
                  max.overlaps = Inf) +  # Increase the max overlaps
  labs(x = "AD1_log2_fc",
       y = "T2D_log2_fc") +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
  theme_bw() +
  theme(
    panel.grid.major = element_blank(),  # Remove major gridlines
    panel.grid.minor = element_blank(),  # Remove minor gridlines
    aspect.ratio=1
  )
```

## 8.2 Plot Between AD2 and T2D Log2FC
```{r Plot Log2FC with AD2 and T2D}
# Combine AD1 and T2D
AD2_T2D_fc <- rbind(X_batch2dat_avg, X_T2Ddat_avg)
# Select only log2FC rows
AD2_T2D_fc <- AD2_T2D_fc[grepl("FC", AD2_T2D_fc$Condition), ]
AD2_T2D_fc <- as.data.frame(AD2_T2D_fc)
# Set the genes as the row names
rownames(AD2_T2D_fc) <- AD2_T2D_fc$Condition
AD2_T2D_fc <- AD2_T2D_fc[, -1]
# Take the transpose
AD2_T2D_fc <- t(AD2_T2D_fc)

# Plot without gene labels
#svg('T2D_AD2_log2fc.svg', width = 4, height = 4)
ggplot(AD2_T2D_fc, aes(x = AD2_log2_fc, y = T2D_log2_fc, label = rownames(AD2_T2D_fc))) +
  geom_point(size=1) +
  labs(x = "AD2_log2_fc",
       y = "T2D_log2_fc") +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
  theme_bw() +
    theme(
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank(),
    aspect.ratio = 1
  )
#dev.off()
```

```{r Gene Labels for AD Cohort 2 Plot}
# Gene Labeling of Different Areas of AD2 Graph
ggplot(AD2_T2D_fc, aes(x = AD2_log2_fc, y = T2D_log2_fc)) +
  geom_point(size=1) +
  geom_text_repel(aes(label = ifelse(AD2_log2_fc > -0.8 & AD2_log2_fc < -0.65 & T2D_log2_fc > -2.5 & T2D_log2_fc < 0, rownames(AD2_T2D_fc), "")), 
                  size = 2, 
                  max.overlaps = Inf) +  # Increase the max overlaps
  labs(x = "AD2_log2_fc",
       y = "T2D_log2_fc") +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
  theme_bw() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),  
    aspect.ratio=1
  )

# Gene Labeling of Different Areas of AD2 Graph
ggplot(AD2_T2D_fc, aes(x = AD2_log2_fc, y = T2D_log2_fc)) +
  geom_point(size=1) +
  geom_text_repel(aes(label = ifelse(AD2_log2_fc > -0.65 & AD2_log2_fc < -0.45 & T2D_log2_fc > -2.5 & T2D_log2_fc < 0, rownames(AD2_T2D_fc), "")), 
                  size = 2, 
                  max.overlaps = Inf) +  # Increase the max overlaps
  labs(x = "AD2_log2_fc",
       y = "T2D_log2_fc") +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
  theme_bw() +
  theme(
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank(), 
    aspect.ratio=1
  )

# Gene Labeling of Different Areas of AD2 Graph
ggplot(AD2_T2D_fc, aes(x = AD2_log2_fc, y = T2D_log2_fc)) +
  geom_point(size=1) +
  geom_text_repel(aes(label = ifelse(AD2_log2_fc > -0.7 & AD2_log2_fc < -0.05 & T2D_log2_fc > 0 & T2D_log2_fc < 2.5, rownames(AD2_T2D_fc), "")), 
                  size = 2, 
                  max.overlaps = Inf) +  # Increase the max overlaps
  labs(x = "AD2_log2_fc",
       y = "T2D_log2_fc") +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
  theme_bw() +
  theme(
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank(),  
    aspect.ratio=1
  )

# Gene Labeling of Different Areas of AD2 Graph
ggplot(AD2_T2D_fc, aes(x = AD2_log2_fc, y = T2D_log2_fc)) +
  geom_point(size=1) +
  geom_text_repel(aes(label = ifelse(AD2_log2_fc > -0.1 & AD2_log2_fc < 0.1 & T2D_log2_fc > 1.8 & T2D_log2_fc < 2.5, rownames(AD2_T2D_fc), "")), 
                  size = 2, 
                  max.overlaps = Inf) +  # Increase the max overlaps
  labs(x = "AD2_log2_fc",
       y = "T2D_log2_fc") +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
  theme_bw() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),  
    aspect.ratio=1
  )

# Gene Labeling of Different Areas of AD2 Graph
ggplot(AD2_T2D_fc, aes(x = AD2_log2_fc, y = T2D_log2_fc)) +
  geom_point(size=1) +
  geom_text_repel(aes(label = ifelse(AD2_log2_fc > 0.14 & AD2_log2_fc < 0.30 & T2D_log2_fc > 0.0 & T2D_log2_fc < 1.6, rownames(AD2_T2D_fc), "")), 
                  size = 2, 
                  max.overlaps = Inf) +  # Increase the max overlaps
  labs(x = "AD2_log2_fc",
       y = "T2D_log2_fc") +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
  theme_bw() +
  theme(
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank(),  
    aspect.ratio=1
  )

# Gene Labeling of Different Areas of AD2 Graph
ggplot(AD2_T2D_fc, aes(x = AD2_log2_fc, y = T2D_log2_fc)) +
  geom_point(size=1) +
  geom_text_repel(aes(label = ifelse(AD2_log2_fc > -0.1 & AD2_log2_fc < 0.1 & T2D_log2_fc > -2.5 & T2D_log2_fc < -1.7, rownames(AD2_T2D_fc), "")), 
                  size = 2, 
                  max.overlaps = Inf) +  # Increase the max overlaps
  labs(x = "AD2_log2_fc",
       y = "T2D_log2_fc") +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
  theme_bw() +
  theme(
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank(), 
    aspect.ratio=1
  )
```

## 8.3 Log2FC of the Top 50 and Bottom 50 Genes in PC2
```{r Top and Bottom 50 Genes in PC2}
# Combine AD1, AD2, and T2D
AD_T2D_fc_all <- rbind(X_batch1dat_avg, X_batch2dat_avg, X_T2Ddat_avg)

# Select only log2FC rows
AD_T2D_fc_all <- AD_T2D_fc_all[grepl("FC", AD_T2D_fc_all$Condition), ]
AD_T2D_fc_all <- as.data.frame(AD_T2D_fc_all)
# Set the genes as the row names
rownames(AD_T2D_fc_all) <- AD_T2D_fc_all$Condition
AD_T2D_fc_all <- AD_T2D_fc_all[, -1]
# Take the transpose
AD_T2D_fc_all <- t(AD_T2D_fc_all)

# Prepare the Q matrix with only PC2
Q_T2D_fc <- as.data.frame(Q_T2D)
Q_T2D_fc <- tibble::rownames_to_column(Q_T2D_fc, var = "geneID")
Q_T2D_fc <- select(Q_T2D_fc, "geneID", "PC2")
# Get the top 50 PC scores
top_50_PC2 <- Q_T2D_fc %>%
  arrange(desc(PC2)) %>%
  slice_head(n = 50)
# Get the bottom 50 PC scores
bottom_50_PC2 <- Q_T2D_fc %>%
  arrange(PC2) %>%
  slice_head(n = 50)
# Combine the top 50 and bottom 50 PC scores into a single data frame
Q_T2D_fc_PC2 <- bind_rows(top_50_PC2, bottom_50_PC2)

# Prepare the gene list with log2 fold change values in T2D, AD1, and AD2
AD_T2D_fc_all <- as.data.frame(AD_T2D_fc_all)
AD_T2D_fc_all <- rownames_to_column(AD_T2D_fc_all, var = "geneID")

# Combine the Q_T2D data and PC dataset
AD_T2D_fc_PC2 <- merge(AD_T2D_fc_all, Q_T2D_fc_PC2, by = "geneID")
# Arrange by descending order 
AD_T2D_fc_PC2 <- AD_T2D_fc_PC2 %>%
  arrange(desc(PC2))

# Removing unnecessary columns not needed for analysis
AD_T2D_fc_PC2_filt <- subset(AD_T2D_fc_PC2, select = -c(5))
# Preparing to make row names
rownames(AD_T2D_fc_PC2_filt) <- AD_T2D_fc_PC2_filt$geneID
AD_T2D_fc_PC2_filt_T2D <- subset(AD_T2D_fc_PC2_filt, select = c(4))
AD_T2D_fc_PC2_filt_AD <- subset(AD_T2D_fc_PC2_filt, select = c(2,3))
AD_T2D_fc_PC2_filt <- subset(AD_T2D_fc_PC2_filt, select = -c(1))
# Convert to matrix format
AD_T2D_fc_PC2_filt_matrix <- as.matrix(AD_T2D_fc_PC2_filt)
AD_T2D_fc_PC2_filt_T2D_matrix <- as.matrix(AD_T2D_fc_PC2_filt_T2D)
AD_T2D_fc_PC2_filt_AD_matrix <- as.matrix(AD_T2D_fc_PC2_filt_AD)

# Ensure all variables are numeric
for (i in 1:ncol(AD_T2D_fc_PC2_filt_matrix)) {
  AD_T2D_fc_PC2_filt_matrix[,i] <- as.numeric(AD_T2D_fc_PC2_filt_matrix[,i])
}
class(AD_T2D_fc_PC2_filt_matrix) <- "numeric"
# Repeat for the T2D group
for (i in 1:ncol(AD_T2D_fc_PC2_filt_T2D_matrix)) {
  AD_T2D_fc_PC2_filt_T2D_matrix[,i] <- as.numeric(AD_T2D_fc_PC2_filt_T2D_matrix[,i])
}
class(AD_T2D_fc_PC2_filt_T2D_matrix) <- "numeric"
# Repeat for the AD group
for (i in 1:ncol(AD_T2D_fc_PC2_filt_AD_matrix)) {
  AD_T2D_fc_PC2_filt_AD_matrix[,i] <- as.numeric(AD_T2D_fc_PC2_filt_AD_matrix[,i])
}
class(AD_T2D_fc_PC2_filt_AD_matrix) <- "numeric"
```

```{r Plot Log2FC of AD1vT2D and AD2vT2D}
# Create new dataframes and apply filters
AD_T2D_fc_PC2_filt <- AD_T2D_fc_PC2
AD_T2D_fc_PC2_filt$geneID <- AD_T2D_fc_PC2_filt$geneID[AD_T2D_fc_PC2_filt$geneID %in% rownames(AD_T2D_fc_PC2_filt_matrix)]

# Set the genes as the row names
rownames(AD_T2D_fc_PC2_filt) <- AD_T2D_fc_PC2_filt$geneID
AD_T2D_fc_PC2_filt <- AD_T2D_fc_PC2_filt[, -1]

for (i in 1:ncol(AD_T2D_fc_PC2_filt)) {
  AD_T2D_fc_PC2_filt[,i] <- as.numeric(AD_T2D_fc_PC2_filt[,i])
}

# Plot AD1 and T2D
# Plot with gene labels
ggplot(AD_T2D_fc_PC2_filt, aes(x = AD1_log2_FC, y = T2D_log2_FC, label = rownames(AD_T2D_fc_PC2_filt))) +
  geom_point(size=1) +
  geom_text(aes(label = ifelse(T2D_log2_FC > 0.1, rownames(AD_T2D_fc_PC2_filt), "")), 
            vjust = -0.5, hjust = 0.5, size = 3) +
  geom_text(aes(label = ifelse(T2D_log2_FC < -0.1, rownames(AD_T2D_fc_PC2_filt), "")), 
            vjust = -0.5, hjust = 0.5, size = 3) +
  geom_text(aes(label = ifelse(AD1_log2_FC > 0.1, rownames(AD_T2D_fc_PC2_filt), "")), 
            vjust = -0.5, hjust = 0.5, size = 3) +
  geom_text(aes(label = ifelse(AD1_log2_FC < -0.1, rownames(AD_T2D_fc_PC2_filt), "")), 
            vjust = -0.5, hjust = 0.5, size = 3) +
  labs(x = "AD1_log2_fc",
       y = "T2D_log2_fc") +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
  theme_bw() +
    theme(
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank(),
    aspect.ratio = 1
  )

# Plot without gene labels
#svg('topbot50_T2D_AD1_log2fc.svg', width = 4, height = 4)
ggplot(AD_T2D_fc_PC2_filt, aes(x = AD1_log2_FC, y = T2D_log2_FC, label = rownames(AD_T2D_fc_PC2_filt))) +
  geom_point(size=1) +
  labs(x = "AD1_log2_fc",
       y = "T2D_log2_fc") +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
  theme_bw() +
    theme(
    panel.grid.major = element_blank(),  
    panel.grid.minor = element_blank(),
    aspect.ratio = 1
  )
#dev.off()

# Plot AD2 with T2D
# Plot with gene labels
ggplot(AD_T2D_fc_PC2_filt, aes(x = AD2_log2_FC, y = T2D_log2_FC, label = rownames(AD_T2D_fc_PC2_filt))) +
  geom_point(size=1) +
  geom_text(aes(label = ifelse(T2D_log2_FC > 0.1, rownames(AD_T2D_fc_PC2_filt), "")), 
            vjust = -0.5, hjust = 0.5, size = 3) +
  geom_text(aes(label = ifelse(T2D_log2_FC < -0.1, rownames(AD_T2D_fc_PC2_filt), "")), 
            vjust = -0.5, hjust = 0.5, size = 3) +
  geom_text(aes(label = ifelse(AD2_log2_FC > 0.1, rownames(AD_T2D_fc_PC2_filt), "")), 
            vjust = -0.5, hjust = 0.5, size = 3) +
  geom_text(aes(label = ifelse(AD2_log2_FC < -0.1, rownames(AD_T2D_fc_PC2_filt), "")), 
            vjust = -0.5, hjust = 0.5, size = 3) +
  labs(x = "AD2_log2_fc",
       y = "T2D_log2_fc") +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
  theme_bw() +
    theme(
    panel.grid.major = element_blank(),  
    panel.grid.minor = element_blank(),
    aspect.ratio = 1
  )

# Plot without gene labels
#svg('topbot50_T2D_AD2_log2fc.svg', width = 4, height = 4)
ggplot(AD_T2D_fc_PC2_filt, aes(x = AD2_log2_FC, y = T2D_log2_FC, label = rownames(AD_T2D_fc_PC2_filt))) +
  geom_point(size=1) +
  labs(x = "AD2_log2_fc",
       y = "T2D_log2_fc") +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
  theme_bw() +
    theme(
    panel.grid.major = element_blank(),  
    panel.grid.minor = element_blank(),
    aspect.ratio = 1
  )
#dev.off()
```

```{r Additional Visualization of Genes in the Plots for AD1}
# Visualization of Genes
ggplot(AD_T2D_fc_PC2_filt, aes(x = AD1_log2_FC, y = T2D_log2_FC)) +
  geom_point(size=1) +
  geom_text_repel(aes(label = ifelse(T2D_log2_FC > 0.1 | T2D_log2_FC < -0.1 | AD1_log2_FC > 0.1 | AD1_log2_FC < -0.4, rownames(AD_T2D_fc_PC2_filt), "")), 
                  size = 1.5) +
  labs(x = "AD1_log2_fc",
       y = "T2D_log2_fc") +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
  theme_bw() +
  theme(
    panel.grid.major = element_blank(),  
    panel.grid.minor = element_blank(),  
    aspect.ratio = 1
  )
```

```{r Additional Visualization of Genes in the Plots for AD2}
# Visualization of Genes
ggplot(AD_T2D_fc_PC2_filt, aes(x = AD2_log2_FC, y = T2D_log2_FC)) +
  geom_point() +
  geom_text_repel(aes(label = ifelse(T2D_log2_FC > 0.1 | T2D_log2_FC < -0.1 | AD2_log2_FC > 0.1 | AD2_log2_FC < -0.1, rownames(AD_T2D_fc_PC2_filt), "")), 
                  size = 1.5) +
  labs(x = "AD2_log2_fc",
       y = "T2D_log2_fc") +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "black") +
  theme_bw() +
  theme(
    panel.grid.major = element_blank(), 
    panel.grid.minor = element_blank(),  
    aspect.ratio = 1
  )
```

# 9 SUPPLEMENTARY INFORMATION
```{r Heatmap of Top and Bottom 50PC Score Genes AD Cohort 2}
#svg('topbot50_T2D_AD2_heatmap1.svg', width = 5, height = 5)
# Make a copy of the X human AD data
X_ADbatch1copy <- X_ADbatch1
# Pull out the gene lists
X_ADbatch1copyGene <- colnames(X_ADbatch1copy)
T2D_topbot50Gene <- rownames(AD_T2D_fc_PC2_filt)

# Subset the matrix to keep only columns that match the overlapping genes
geneoverlap_AD2 <- intersect(X_ADbatch1copyGene, T2D_topbot50Gene)
X_ADbatch1copy_filt <- X_ADbatch1copy[, geneoverlap_AD2]

# Subset the matrix to keep only columns that match the overlapping genes
X_ADbatch1copy_filt <- t(X_ADbatch1copy_filt)
annotation_df2 <- data.frame(Condition = T2D_AD_TCR_group$Condition)
rownames(annotation_df2) <- T2D_AD_TCR_group$SubjectID

# Ensure the row names of the dataset match the SubjectID
subject_ids <- colnames(X_ADbatch1copy_filt)
subject_conditions <- T2D_AD_TCR_group$Condition[match(subject_ids, T2D_AD_TCR_group$SubjectID)]
# Create a data frame for easy sorting
order_df <- data.frame(SubjectID = subject_ids, Condition = subject_conditions)
order_df <- order_df[order(order_df$Condition, order_df$SubjectID), ]
# Reorder the columns of based on AD and C
X_ADbatch1copy_filt <- X_ADbatch1copy_filt[, order_df$SubjectID]

# Define colors for the conditions
annotation_colors <- list(Condition = c(AD = "red", C = "blue"))

# Generate the heat map
heatmapfig_PC2 <- pheatmap(X_ADbatch1copy_filt,
  cluster_rows = T,
  cluster_cols = F,
  color = colorRampPalette(c("dodgerblue3", "white", "firebrick2"))(100),
  border_color = "black",
  breaks = seq(-2.5, 2.5, length.out = 100),
  angle_col = 90,
  fontsize_col = 3,
  fontsize_row = 3,
  annotation_col = annotation_df2,
  annotation_colors = annotation_colors
)
#dev.off()
```

```{r Heatmap of Top and Bottom 50PC Score Genes AD Cohort 2}
#svg('topbot50_T2D_AD2_heatmap2.svg', width = 5, height = 5)
# Make a copy of the X human AD data
X_ADbatch2copy <- X_ADbatch2
# Pull out the gene lists
X_ADbatch2copyGene <- colnames(X_ADbatch2copy)
T2D_topbot50Gene <- rownames(AD_T2D_fc_PC2_filt)

# Subset the matrix to keep only columns that match the overlapping genes
geneoverlap_AD2 <- intersect(X_ADbatch2copyGene, T2D_topbot50Gene)
X_ADbatch2copy_filt <- X_ADbatch2copy[, geneoverlap_AD2]

# Subset the matrix to keep only columns that match the overlapping genes
X_ADbatch2copy_filt <- t(X_ADbatch2copy_filt)
annotation_df2 <- data.frame(Condition = T2D_AD_TCR_group2$Condition)
rownames(annotation_df2) <- T2D_AD_TCR_group2$SubjectID

# Ensure the row names of the dataset match the SubjectID in T2D_AD_TCR_group
subject_ids <- colnames(X_ADbatch2copy_filt)
subject_conditions <- T2D_AD_TCR_group2$Condition[match(subject_ids, T2D_AD_TCR_group2$SubjectID)]
# Create a data frame for easy sorting
order_df <- data.frame(SubjectID = subject_ids, Condition = subject_conditions)
order_df <- order_df[order(order_df$Condition, order_df$SubjectID), ]
# Reorder the columns of based on AD and C
X_ADbatch2copy_filt <- X_ADbatch2copy_filt[, order_df$SubjectID]

# Define colors for the conditions
annotation_colors <- list(Condition = c(AD = "red", C = "blue"))

# Generate the heat map
heatmapfig_PC2 <- pheatmap(X_ADbatch2copy_filt,
  cluster_rows = T,
  cluster_cols = F,
  color = colorRampPalette(c("dodgerblue3", "white", "firebrick2"))(100),
  border_color = "black",
  breaks = seq(-2.5, 2.5, length.out = 100),
  angle_col = 90,
  fontsize_col = 3,
  fontsize_row = 3,
  annotation_col = annotation_df2,
  annotation_colors = annotation_colors
)
#dev.off()
```

# DEMOGRAPHICS
```{r Demographic Information for T2D}
# Separate subset of the T2D for only demographic information
XT2D_demographics <- X_T2Ddat[,c(1:6)]

# Create data frame for AD group and Control group
XT2D_demo_T2D <- XT2D_demographics[XT2D_demographics$Condition %in% "T2D",]
XT2D_demo_C <- XT2D_demographics[XT2D_demographics$Condition %in% "C",]

# Count demographic information for AD
# Count occurrences of each gender
XT2D_demo_T2D$Sex <- factor(XT2D_demo_T2D$Sex, levels = c("M", "F"))
T2D_sex_counts_T2D <- table(XT2D_demo_T2D$Sex)
# Calculate mean and standard deviation of the age for AD group
T2D_age_stats_T2D <- XT2D_demo_T2D %>% summarise(
                                            mean_age = mean(Age, na.rm = TRUE),
                                            sd_age = sd(Age, na.rm = TRUE)
                                           )

# Count demographic information for Control
# Count occurrences of each gender
XT2D_demo_C$Sex <- factor(XT2D_demo_C$Sex, levels = c("M", "F"))
T2D_sex_counts_C <- table(XT2D_demo_C$Sex)
# Calculate mean and standard deviation of the age for Control group
T2D_age_stats_C <- XT2D_demo_C %>% summarise(
                                            mean_age = mean(Age, na.rm = TRUE),
                                            sd_age = sd(Age, na.rm = TRUE)
                                           )
```

```{r Demographic Information for AD Cohort 1}
# Separate subset of the AD batch 1 for only demographic information
Xbatch1_demographics <- X_batch1dat[,c(1:4)]

# Create data frame for AD group and Control group
Xbatch1_demo_AD <- Xbatch1_demographics[Xbatch1_demographics$Condition %in% "AD",]
Xbatch1_demo_C <- Xbatch1_demographics[Xbatch1_demographics$Condition %in% "C",]

# Count demographic information for AD
# Count occurrences of each gender
Xbatch1_demo_AD$Sex <- factor(Xbatch1_demo_AD$Sex, levels = c("M", "F"))
batch1_sex_counts_AD <- table(Xbatch1_demo_AD$Sex)
# Calculate mean and standard deviation of the age for AD group
batch1_age_stats_AD <- Xbatch1_demo_AD %>% summarise(
                                            mean_age = mean(Age, na.rm = TRUE),
                                            sd_age = sd(Age, na.rm = TRUE)
                                           )

# Count demographic information for Control
# Count occurrences of each gender
Xbatch1_demo_C$Sex <- factor(Xbatch1_demo_C$Sex, levels = c("M", "F"))
batch1_sex_counts_C <- table(Xbatch1_demo_C$Sex)
# Calculate mean and standard deviation of the age for Control group
batch1_age_stats_C <- Xbatch1_demo_C %>% summarise(
                                            mean_age = mean(Age, na.rm = TRUE),
                                            sd_age = sd(Age, na.rm = TRUE)
                                           )
```

```{r Demographic Information for AD Cohort 2}
# Separate subset of the AD batch 2 for only demographic information
Xbatch2_demographics <- X_batch2dat[,c(1:4)]

# Create data frame for AD group and Control group
Xbatch2_demo_AD <- Xbatch2_demographics[Xbatch2_demographics$Condition %in% "AD",]
Xbatch2_demo_C <- Xbatch2_demographics[Xbatch2_demographics$Condition %in% "C",]

# Count demographic information for AD
# Count occurrences of each gender
Xbatch2_demo_AD$Sex <- factor(Xbatch2_demo_AD$Sex, levels = c("M", "F"))
batch2_sex_counts_AD <- table(Xbatch2_demo_AD$Sex)
# Calculate mean and standard deviation of the age for AD group
batch2_age_stats_AD <- Xbatch2_demo_AD %>% summarise(
                                            mean_age = mean(Age, na.rm = TRUE),
                                            sd_age = sd(Age, na.rm = TRUE)
                                           )

# Count demographic information for Control
# Count occurrences of each gender
Xbatch2_demo_C$Sex <- factor(Xbatch2_demo_C$Sex, levels = c("M", "F"))
batch2_sex_counts_C <- table(Xbatch2_demo_C$Sex)
# Calculate mean and standard deviation of the age for Control group
batch2_age_stats_C <- Xbatch2_demo_C %>% summarise(
                                            mean_age = mean(Age, na.rm = TRUE),
                                            sd_age = sd(Age, na.rm = TRUE)
                                           )
```

```{r Export Q_T2D Data}
# Export Q_T2D datalist for further analysis
#write.csv(Q_T2D_GSE, "Q_T2D_list.csv")
```

********* END OF SCRIPT *********























